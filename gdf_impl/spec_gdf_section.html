   <h4 class="heading settled" data-level="7.19.5" id="apply_gdf_filter_process"><span class="secno">7.19.5. </span><span class="content">Apply GDF filter process</span><a class="self-link" href="#apply_gdf_filter_process"></a></h4>
   <p>The inputs to this process are:</p>
   <ul>
    <li data-md>
     <p>variables x and y specifying the location of the top-left luma sample in a GDF unit,</p>
    <li data-md>
     <p>variables qpIdx and refDstIdx specifying which set of tables are active,</p>
    <li data-md>
     <p>variables w and h specifying the size of the GDF unit,</p>
    <li data-md>
     <p>a variable stripeEndY specifying the unclipped end of the current 64 pixel high stripe.</p>
   </ul>
   <p>The curvature in different directions is estimated in the array grad as follows:</p>
<pre class="language-cpp highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- k>for</c-><c- p>(</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>&lt;</c-> <c- n>h</c-><c- o>+</c-><c- mi>3</c-><c- p>;</c-> <c- n>i</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- k>for</c-><c- p>(</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>j</c-> <c- o>&lt;</c-> <c- n>w</c-><c- o>+</c-><c- mi>3</c-><c- p>;</c-> <c- n>j</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="3"></span><span class="line">        <c- k>for</c-><c- p>(</c-> <c- n>d</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>d</c-> <c- o>&lt;</c-> <c- mi>4</c-><c- p>;</c-> <c- n>d</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="4"></span><span class="line">            <c- k>if</c-> <c- p>(</c-><c- n>d</c-> <c- o>==</c-> <c- n>GDF_VER</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="5"></span><span class="line">                <c- n>dx</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="6"></span><span class="line">                <c- n>dy</c-> <c- o>=</c-> <c- mi>1</c-></span><span class="line-no" data-line="7"></span><span class="line">            <c- p>}</c-> <c- k>else</c-> <c- k>if</c-> <c- p>(</c-><c- n>d</c-> <c- o>==</c-> <c- n>GDF_HOR</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="8"></span><span class="line">                <c- n>dx</c-> <c- o>=</c-> <c- mi>1</c-></span><span class="line-no" data-line="9"></span><span class="line">                <c- n>dy</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="10"></span><span class="line">            <c- p>}</c-> <c- k>else</c-> <c- k>if</c-> <c- p>(</c-><c- n>d</c-> <c- o>==</c-> <c- n>GDF_DIAG0</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="11"></span><span class="line">                <c- n>dx</c-> <c- o>=</c-> <c- mi>1</c-></span><span class="line-no" data-line="12"></span><span class="line">                <c- n>dy</c-> <c- o>=</c-> <c- mi>1</c-></span><span class="line-no" data-line="13"></span><span class="line">            <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="14"></span><span class="line">                <c- n>dx</c-> <c- o>=</c-> <c- mi>1</c-></span><span class="line-no" data-line="15"></span><span class="line">                <c- n>dy</c-> <c- o>=</c-> <c- mi>-1</c-></span><span class="line-no" data-line="16"></span><span class="line">            <c- p>}</c-></span><span class="line-no" data-line="17"></span><span class="line">            <c- k>if</c-> <c- p>(</c-> <c- n>y</c-> <c- o>+</c-> <c- n>i</c-> <c- o>>=</c-> <c- n>stripeEndY</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="18"></span><span class="line">                <c- n>i2</c-> <c- o>=</c-> <c- n>i</c-> <c- o>-</c-> <c- mi>2</c-></span><span class="line-no" data-line="19"></span><span class="line">                <c- n>a</c-> <c- o>=</c-> <c- n>get_gdf_sample</c-><c- p>(</c-> <c- n>x</c-> <c- o>+</c-> <c- n>j</c-> <c- o>-</c-> <c- n>dx</c-><c- p>,</c-> <c- n>y</c-> <c- o>+</c-> <c- n>i2</c-> <c- o>-</c-> <c- n>dy</c-> <c- p>)</c-></span><span class="line-no" data-line="20"></span><span class="line">                <c- n>b</c-> <c- o>=</c-> <c- n>get_gdf_sample</c-><c- p>(</c-> <c- n>x</c-> <c- o>+</c-> <c- n>j</c-><c- p>,</c-> <c- n>y</c-> <c- o>+</c-> <c- n>i2</c-> <c- p>)</c-></span><span class="line-no" data-line="21"></span><span class="line">                <c- n>c</c-> <c- o>=</c-> <c- n>get_gdf_sample</c-><c- p>(</c-> <c- n>x</c-> <c- o>+</c-> <c- n>j</c-> <c- o>+</c-> <c- n>dx</c-><c- p>,</c-> <c- n>y</c-> <c- o>+</c-> <c- n>i2</c-> <c- o>+</c-> <c- n>dy</c-> <c- p>)</c-></span><span class="line-no" data-line="22"></span><span class="line">            <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="23"></span><span class="line">                <c- n>a</c-> <c- o>=</c-> <c- n>get_gdf_sample</c-><c- p>(</c-> <c- n>x</c-> <c- o>+</c-> <c- n>j</c-> <c- o>-</c-> <c- n>dx</c-><c- p>,</c-> <c- n>y</c-> <c- o>+</c-> <c- n>i</c-> <c- o>-</c-> <c- n>dy</c-> <c- p>)</c-></span><span class="line-no" data-line="24"></span><span class="line">                <c- n>b</c-> <c- o>=</c-> <c- n>get_gdf_sample</c-><c- p>(</c-> <c- n>x</c-> <c- o>+</c-> <c- n>j</c-><c- p>,</c-> <c- n>y</c-> <c- o>+</c-> <c- n>i</c-> <c- p>)</c-></span><span class="line-no" data-line="25"></span><span class="line">                <c- n>c</c-> <c- o>=</c-> <c- n>get_gdf_sample</c-><c- p>(</c-> <c- n>x</c-> <c- o>+</c-> <c- n>j</c-> <c- o>+</c-> <c- n>dx</c-><c- p>,</c-> <c- n>y</c-> <c- o>+</c-> <c- n>i</c-> <c- o>+</c-> <c- n>dy</c-> <c- p>)</c-></span><span class="line-no" data-line="26"></span><span class="line">            <c- p>}</c-></span><span class="line-no" data-line="27"></span><span class="line">            <c- n>grad</c-><c- p>[</c-><c- n>d</c-><c- p>][</c-><c- n>i</c-><c- p>][</c-><c- n>j</c-><c- p>]</c-> <c- o>=</c-> <c- n>Abs</c-><c- p>(</c-> <c- n>b</c-> <c- o>*</c-> <c- mi>2</c-> <c- o>-</c-> <c- n>a</c-> <c- o>-</c-> <c- n>c</c-> <c- p>)</c-></span><span class="line-no" data-line="28"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="29"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="30"></span><span class="line"><c- p>}</c-></span></pre>
   <p>where the function get_gdf_sample (which gets a sample from the current stripe
with reflection at the stripe end) is specified as:</p>
<pre class="language-cpp highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>get_gdf_sample</c-><c- p>(</c-> <c- n>x</c-><c- p>,</c-> <c- n>y</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- n>shift</c-> <c- o>=</c-> <c- n>BitDepth</c-> <c- o>==</c-> <c- mi>12</c-> <c- o>?</c-> <c- mi>2</c-> <c- o>:</c-> <c- mi>0</c-></span><span class="line-no" data-line="3"></span><span class="line">    <c- k>return</c-> <c- n>get_luma_source_sample</c-><c- p>(</c-><c- n>x</c-><c- p>,</c-><c- n>y</c-><c- p>)</c-> <c- o>>></c-> <c- n>shift</c-></span><span class="line-no" data-line="4"></span><span class="line"><c- p>}</c-></span></pre>
   <p>The array gdfCls (containing the filter class for each sample) is derived as follows:</p>
<pre class="language-cpp highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>i</c-> <c- o>=</c-> <c- p>(</c-><c- n>h</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- o>-</c-> <c- mi>1</c-><c- p>;</c-> <c- n>i</c-> <c- o>>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-><c- o>--</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- k>for</c-><c- p>(</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>j</c-> <c- o>&lt;</c-> <c- n>w</c-> <c- o>>></c-> <c- mi>1</c-> <c- p>;</c-><c- n>j</c-><c- o>++</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="3"></span><span class="line">        <c- k>for</c-><c- p>(</c-> <c- n>d</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>d</c-> <c- o>&lt;</c-> <c- mi>4</c-><c- p>;</c-> <c- n>d</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="4"></span><span class="line">            <c- n>str</c-><c- p>[</c-> <c- n>d</c-> <c- p>]</c-> <c- o>=</c-> <c- n>grad_sum</c-><c- p>(</c-><c- n>grad</c-><c- p>[</c-><c- n>d</c-><c- p>],</c-><c- n>i</c-><c- o>*</c-><c- mi>2</c-><c- p>,</c-><c- n>j</c-><c- o>*</c-><c- mi>2</c-><c- p>,</c-><c- mi>4</c-><c- p>,</c-><c- mi>4</c-><c- p>)</c-></span><span class="line-no" data-line="5"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="6"></span><span class="line">        <c- n>cls</c-> <c- o>=</c-> <c- n>str</c-><c- p>[</c-><c- n>GDF_VER</c-><c- p>]</c-> <c- o>></c-> <c- n>str</c-><c- p>[</c-><c- n>GDF_HOR</c-><c- p>]</c-> <c- o>?</c-> <c- mi>0</c-> <c- o>:</c-> <c- mi>1</c-></span><span class="line-no" data-line="7"></span><span class="line">        <c- n>cls</c-> <c- o>|=</c-> <c- n>str</c-><c- p>[</c-><c- n>GDF_DIAG0</c-><c- p>]</c-> <c- o>></c-> <c- n>str</c-><c- p>[</c-><c- n>GDF_DIAG1</c-><c- p>]</c-> <c- o>?</c-> <c- mi>0</c-> <c- o>:</c-> <c- mi>2</c-></span><span class="line-no" data-line="8"></span><span class="line">        <c- n>gdfCls</c-><c- p>[</c-> <c- n>i</c-> <c- p>][</c-> <c- n>j</c-> <c- p>]</c-> <c- o>=</c-> <c- n>cls</c-></span><span class="line-no" data-line="9"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="10"></span><span class="line"><c- p>}</c-></span></pre>
   <p>The function grad_sum sums a rectangle of the values in an array as follows:</p>
<pre class="language-cpp highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>grad_sum</c-><c- p>(</c-><c- n>grad</c-><c- p>,</c-><c- n>i</c-><c- p>,</c-><c- n>j</c-><c- p>,</c-><c- n>down</c-><c- p>,</c-><c- n>across</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- n>t</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="3"></span><span class="line">    <c- k>for</c-><c- p>(</c-> <c- n>i2</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i2</c-> <c- o>&lt;</c-> <c- n>down</c-><c- p>;</c-> <c- n>i2</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="4"></span><span class="line">        <c- k>for</c-><c- p>(</c-> <c- n>j2</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>j2</c-> <c- o>&lt;</c-> <c- n>across</c-><c- p>;</c-> <c- n>j2</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="5"></span><span class="line">            <c- n>t</c-> <c- o>+=</c-> <c- n>grad</c-><c- p>[</c-><c- n>i</c-> <c- o>+</c-> <c- n>i2</c-><c- p>][</c-><c- n>j</c-> <c- o>+</c-> <c- n>j2</c-><c- p>]</c-></span><span class="line-no" data-line="6"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="7"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="8"></span><span class="line">    <c- k>return</c-> <c- n>t</c-></span><span class="line-no" data-line="9"></span><span class="line"><c- p>}</c-></span></pre>
   <p class="note" role="note"><span class="marker">Note:</span> <code>get_gdf_sample</code> returns values representable by an unsigned integer with <code>Min( 10, BitDepth )</code> bits.
The array <code>grad</code> contains values representable by an unsigned integer with <code>Min( 10, BitDepth ) + 1</code> bits. <code>grad_sum</code> sums 16 values within grad.  This means <code>grad_sum</code> returns values representable by an unsigned integer with <code>Min( 10, BitDepth ) + 5</code> bits.</p>
   <p>The scaling used for this unit is prepared as follows:</p>
<pre class="language-cpp highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- k>if</c-> <c- p>(</c-> <c- n>refDstIdx</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- n>scale</c-> <c- o>=</c-> <c- mi>8</c-></span><span class="line-no" data-line="3"></span><span class="line"><c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="4"></span><span class="line">    <c- n>scale</c-> <c- o>=</c-> <c- mi>5</c-></span><span class="line-no" data-line="5"></span><span class="line"><c- p>}</c-></span></pre>
   <p>The luma samples in LrFrame are modified as follows:</p>
<pre class="language-cpp highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- k>for</c-><c- p>(</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>&lt;</c-> <c- n>h</c-><c- p>;</c-> <c- n>i</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- n>y2</c-> <c- o>=</c-> <c- n>i</c-> <c- o>+</c-> <c- n>y</c-></span><span class="line-no" data-line="3"></span><span class="line">    <c- k>for</c-> <c- p>(</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>j</c-> <c- o>&lt;</c-> <c- n>w</c-><c- p>;</c-> <c- n>j</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="4"></span><span class="line">        <c- n>x2</c-> <c- o>=</c-> <c- n>x</c-> <c- o>+</c-> <c- n>j</c-></span><span class="line-no" data-line="5"></span><span class="line">        <c- n>cls</c-> <c- o>=</c-> <c- n>gdfCls</c-><c- p>[</c-><c- n>i</c-> <c- o>>></c-> <c- mi>1</c-><c- p>][</c-><c- n>j</c-> <c- o>>></c-> <c- mi>1</c-><c- p>]</c-></span><span class="line-no" data-line="6"></span><span class="line">        <c- k>for</c-><c- p>(</c-> <c- n>idx</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>idx</c-> <c- o>&lt;</c-> <c- mi>3</c-><c- p>;</c-> <c- n>idx</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="7"></span><span class="line">            <c- n>gdfIdx</c-><c- p>[</c-> <c- n>idx</c-> <c- p>]</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="8"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="9"></span><span class="line">        <c- k>for</c-><c- p>(</c-> <c- n>k</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>k</c-> <c- o>&lt;</c-> <c- mi>18</c-> <c- o>+</c-> <c- mi>4</c-><c- p>;</c-> <c- n>k</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="10"></span><span class="line">            <c- n>alpha</c-> <c- o>=</c-> <c- n>Gdf_Alpha</c-><c- p>[</c-> <c- n>refDstIdx</c-> <c- p>][</c-> <c- n>qpIdx</c-> <c- p>][</c-> <c- n>k</c-> <c- p>][</c-> <c- n>cls</c-> <c- p>]</c-></span><span class="line-no" data-line="11"></span><span class="line">            <c- k>if</c-> <c- p>(</c-> <c- n>k</c-> <c- o>&lt;</c-> <c- mi>18</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="12"></span><span class="line">                <c- n>dy</c-> <c- o>=</c-> <c- n>Gdf_Coords</c-><c- p>[</c-><c- n>k</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-></span><span class="line-no" data-line="13"></span><span class="line">                <c- n>dx</c-> <c- o>=</c-> <c- n>Gdf_Coords</c-><c- p>[</c-><c- n>k</c-><c- p>][</c-><c- mi>1</c-><c- p>]</c-></span><span class="line-no" data-line="14"></span><span class="line">                <c- n>x3</c-> <c- o>=</c-> <c- n>x2</c-> <c- o>-</c-> <c- n>dx</c-></span><span class="line-no" data-line="15"></span><span class="line">                <c- n>y3</c-> <c- o>=</c-> <c- n>y2</c-> <c- o>-</c-> <c- n>dy</c-></span><span class="line-no" data-line="16"></span><span class="line">                <c- n>x4</c-> <c- o>=</c-> <c- n>x2</c-> <c- o>+</c-> <c- n>dx</c-></span><span class="line-no" data-line="17"></span><span class="line">                <c- n>y4</c-> <c- o>=</c-> <c- n>y2</c-> <c- o>+</c-> <c- n>dy</c-></span><span class="line-no" data-line="18"></span><span class="line">                <c- n>sample2</c-> <c- o>=</c-> <c- n>get_gdf_sample</c-><c- p>(</c-><c- n>x2</c-><c- p>,</c-><c- n>y2</c-><c- p>)</c-></span><span class="line-no" data-line="19"></span><span class="line">                <c- n>sample3</c-> <c- o>=</c-> <c- n>get_gdf_sample</c-><c- p>(</c-><c- n>x3</c-><c- p>,</c-><c- n>y3</c-><c- p>)</c-></span><span class="line-no" data-line="20"></span><span class="line">                <c- n>sample4</c-> <c- o>=</c-> <c- n>get_gdf_sample</c-><c- p>(</c-><c- n>x4</c-><c- p>,</c-><c- n>y4</c-><c- p>)</c-></span><span class="line-no" data-line="21"></span><span class="line">                <c- n>above</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- o>-</c-><c- n>alpha</c-><c- p>,</c-> <c- n>alpha</c-><c- p>,</c-> </span><span class="line-no" data-line="22"></span><span class="line">                               <c- p>(</c-> <c- n>sample3</c->  <c- o>-</c-> <c- n>sample2</c-><c- p>)</c-> <c- o>&lt;&lt;</c-> </span><span class="line-no" data-line="23"></span><span class="line">                                   <c- p>(</c-><c- mi>10</c-> <c- o>-</c-> <c- n>Min</c-><c- p>(</c-> <c- mi>10</c-><c- p>,</c-> <c- n>BitDepth</c-><c- p>)</c-> <c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="24"></span><span class="line">                <c- n>below</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- o>-</c-><c- n>alpha</c-><c- p>,</c-> <c- n>alpha</c-><c- p>,</c-> </span><span class="line-no" data-line="25"></span><span class="line">                               <c- p>(</c-> <c- n>sample4</c-> <c- o>-</c-> <c- n>sample2</c-> <c- p>)</c-> <c- o>&lt;&lt;</c-></span><span class="line-no" data-line="26"></span><span class="line">                                   <c- p>(</c-><c- mi>10</c-> <c- o>-</c-> <c- n>Min</c-><c- p>(</c-> <c- mi>10</c-><c- p>,</c-> <c- n>BitDepth</c-><c- p>)</c-> <c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="27"></span><span class="line">                <c- n>comb</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- mi>-512</c-><c- p>,</c-> <c- mi>511</c-><c- p>,</c-> <c- n>above</c-> <c- o>+</c-> <c- n>below</c-> <c- p>)</c-></span><span class="line-no" data-line="28"></span><span class="line">            <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="29"></span><span class="line">                <c- n>d</c-> <c- o>=</c-> <c- n>k</c-> <c- o>-</c-> <c- mi>18</c-></span><span class="line-no" data-line="30"></span><span class="line">                <c- n>v</c-> <c- o>=</c-> <c- n>grad_sum</c-><c- p>(</c-><c- n>grad</c-><c- p>[</c-><c- n>d</c-><c- p>],(</c-><c- n>i</c-><c- o>>></c-><c- mi>1</c-><c- p>)</c-><c- o>&lt;&lt;</c-><c- mi>1</c-><c- p>,(</c-><c- n>j</c-><c- o>>></c-><c- mi>1</c-><c- p>)</c-><c- o>&lt;&lt;</c-><c- mi>1</c-><c- p>,</c-><c- mi>4</c-><c- p>,</c-><c- mi>4</c-><c- p>)</c-></span><span class="line-no" data-line="31"></span><span class="line">                <c- k>if</c-> <c- p>(</c-> <c- n>BitDepth</c-> <c- o>==</c-> <c- mi>8</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="32"></span><span class="line">                    <c- n>v</c-> <c- o>=</c-> <c- n>v</c-> <c- o>>></c-> <c- mi>2</c-></span><span class="line-no" data-line="33"></span><span class="line">                <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="34"></span><span class="line">                    <c- n>v</c-> <c- o>=</c-> <c- n>v</c-> <c- o>>></c-> <c- mi>4</c-></span><span class="line-no" data-line="35"></span><span class="line">                <c- p>}</c-></span><span class="line-no" data-line="36"></span><span class="line">                <c- n>comb</c-> <c- o>=</c-> <c- n>Min</c-><c- p>(</c-> <c- n>v</c-><c- p>,</c-> <c- n>alpha</c-> <c- p>)</c-></span><span class="line-no" data-line="37"></span><span class="line">                <c- n>comb</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- mi>-512</c-><c- p>,</c-> <c- mi>511</c-><c- p>,</c-> <c- n>comb</c-> <c- p>)</c-></span><span class="line-no" data-line="38"></span><span class="line">            <c- p>}</c-></span><span class="line-no" data-line="39"></span><span class="line">            <c- k>for</c-><c- p>(</c-> <c- n>idx</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>idx</c-> <c- o>&lt;</c-> <c- mi>3</c-><c- p>;</c-> <c- n>idx</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="40"></span><span class="line">                <c- n>gdfIdx</c-><c- p>[</c-> <c- n>idx</c-> <c- p>]</c-> <c- o>+=</c-></span><span class="line-no" data-line="41"></span><span class="line">                    <c- n>comb</c-> <c- o>*</c-> <c- n>Gdf_Weight</c-><c- p>[</c-> <c- n>refDstIdx</c-> <c- p>][</c-> <c- n>qpIdx</c-> <c- p>][</c-> <c- n>idx</c-> <c- p>][</c-> <c- n>k</c-> <c- p>][</c-> <c- n>cls</c-> <c- p>]</c-></span><span class="line-no" data-line="42"></span><span class="line">            <c- p>}</c-></span><span class="line-no" data-line="43"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="44"></span><span class="line">        <c- n>pos</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="45"></span><span class="line">        <c- k>for</c-><c- p>(</c-> <c- n>idx</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>idx</c-> <c- o>&lt;</c-> <c- mi>3</c-><c- p>;</c-> <c- n>idx</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="46"></span><span class="line">            <c- n>v</c-> <c- o>=</c-> <c- n>Round2Signed</c-><c- p>(</c-></span><span class="line-no" data-line="47"></span><span class="line">                    <c- p>(</c-> <c- n>gdfIdx</c-><c- p>[</c-> <c- n>idx</c-> <c- p>]</c-> <c- o>+</c-> <c- n>Gdf_Bias</c-><c- p>[</c-> <c- n>refDstIdx</c-> <c- p>][</c-> <c- n>qpIdx</c-> <c- p>][</c-> <c- n>idx</c-> <c- p>]</c-> <c- p>)</c-> <c- o>*</c-></span><span class="line-no" data-line="48"></span><span class="line">                    <c- n>scale</c-><c- p>,</c-> <c- mi>15</c-> <c- p>)</c-></span><span class="line-no" data-line="49"></span><span class="line">            <c- n>pos</c-> <c- o>=</c-> <c- n>pos</c-> <c- o>*</c-> <c- n>scale</c-> <c- o>*</c-> <c- mi>2</c-> <c- o>+</c-> <c- n>Clip3</c-><c- p>(</c-> <c- o>-</c-><c- n>scale</c-><c- p>,</c-> <c- n>scale</c-> <c- o>-</c-> <c- mi>1</c-><c- p>,</c-> <c- n>v</c-> <c- p>)</c-> <c- o>+</c-> <c- n>scale</c-> </span><span class="line-no" data-line="50"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="51"></span><span class="line">        <c- k>if</c-> <c- p>(</c-> <c- n>refDstIdx</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="52"></span><span class="line">            <c- n>err</c-> <c- o>=</c-> <c- n>Gdf_Intra_Error</c-><c- p>[</c-> <c- n>qpIdx</c-> <c- p>][</c-> <c- n>pos</c-> <c- p>]</c-></span><span class="line-no" data-line="53"></span><span class="line">        <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="54"></span><span class="line">            <c- n>err</c-> <c- o>=</c-> <c- n>Gdf_Inter_Error</c-><c- p>[</c-> <c- n>refDstIdx</c-> <c- o>-</c-> <c- mi>1</c-> <c- p>][</c-> <c- n>qpIdx</c-> <c- p>][</c-> <c- n>pos</c-> <c- p>]</c-></span><span class="line-no" data-line="55"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="56"></span><span class="line">        <c- n>res</c-> <c- o>=</c-> <c- n>Clip1</c-><c- p>(</c-> <c- n>LrFrame</c-><c- p>[</c-> <c- mi>0</c-> <c- p>][</c-> <c- n>y2</c-> <c- p>][</c-> <c- n>x2</c-> <c- p>]</c-> <c- o>+</c-></span><span class="line-no" data-line="57"></span><span class="line">                     <c- n>Round2Signed</c-><c- p>(</c-> <c- n>err</c-> <c- o>*</c-> <c- n>GdfPixScale</c-><c- p>,</c-><c- mi>12</c-> <c- o>-</c-> <c- n>BitDepth</c-> <c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="58"></span><span class="line">        <c- n>s</c-> <c- o>=</c-> <c- n>SegmentIds</c-><c- p>[</c-> <c- n>y2</c-> <c- o>>></c-> <c- n>MI_SIZE_LOG2</c-> <c- p>][</c-> <c- n>x2</c-> <c- o>>></c-> <c- n>MI_SIZE_LOG2</c-> <c- p>]</c-></span><span class="line-no" data-line="59"></span><span class="line">        <c- k>if</c-> <c- p>(</c-> <c- o>!</c-><c- n>LosslessArray</c-><c- p>[</c-> <c- n>s</c-> <c- p>]</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="60"></span><span class="line">            <c- n>LrFrame</c-><c- p>[</c-> <c- mi>0</c-> <c- p>][</c-> <c- n>y2</c-> <c- p>][</c-> <c- n>x2</c-> <c- p>]</c-> <c- o>=</c-> <c- n>res</c-></span><span class="line-no" data-line="61"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="62"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="63"></span><span class="line"><c- p>}</c-> </span></pre>
   <p>where the constant table Gdf_Coords is specified as:</p>
<pre class="line-numbered"><span class="line-no" data-line="1"></span><span class="line">Gdf_Coords[18][2] = {</span><span class="line-no" data-line="2"></span><span class="line">                                  { 6,  0},</span><span class="line-no" data-line="3"></span><span class="line">                                  { 5,  0},</span><span class="line-no" data-line="4"></span><span class="line">                                  { 4,  0},</span><span class="line-no" data-line="5"></span><span class="line">                                  { 3,  0},</span><span class="line-no" data-line="6"></span><span class="line">                        { 2,  1}, { 2,  0}, { 2, -1},</span><span class="line-no" data-line="7"></span><span class="line">              { 1,  2}, { 1,  1}, { 1,  0}, { 1, -1}, { 1, -2},</span><span class="line-no" data-line="8"></span><span class="line">    { 0,  6}, { 0,  5}, { 0,  4}, { 0,  3}, { 0,  2}, { 0,  1}</span><span class="line-no" data-line="9"></span><span class="line">}</span></pre>
   <h3 class="heading settled" data-level="7.20" id="output_process"><span class="secno">7.20. </span><span class="content">Output process</span><a class="self-link" href="#output_process"></a></h3>
   <h4 class="heading settled" data-level="7.20.1" id="output_process_general"><span class="secno">7.20.1. </span><span class="content">General</span><a class="self-link" href="#output_process_general"></a></h4>
   <p>The input to this process is a variable frameToShowMapIdx specifying
which frame to output.  If frameToShowMapIdx is equal to -1, the process
will output the current frame.  Otherwise, frameToShowMapIdx indicates
which previously decoded frame to output.</p>
   <p>This process is invoked to prepare output frames.</p>
   <p>If scalability is being used (OperatingPointIdc not equal to 0),
an application-specific function is called to decide whether this frame will be output.
If this function returns a value equal to 0, then this process terminates immediately.</p>
   <p class="note" role="note"><span class="marker">Note:</span> Applications that are displaying the decoded video are expected to only display
one frame from each temporal unit within the selected operating point.
This frame should be the highest spatial layer that is both within the operating point and present
within the temporal unit.
Other applications may set their own policy about which frames are output.</p>
   <p>The intermediate output preparation process specified in <a href="#intermediate_output_preparation_process">§ 7.20.2 Intermediate output preparation process</a> is invoked with an input of frameToShowMapIdx to prepare arrays OutY, OutU, and OutV, and the outputs are assigned to bitDepth, w, h, subX, subY, filmGrainPresent, numPlanes, and mcIdentity.</p>
   <p>If filmGrainPresent is equal to 1 and apply_grain is equal to 1, then
the film grain synthesis process specified in <a href="#film_grain_synthesis_process">§ 7.20.7 Film grain synthesis process</a> is invoked with inputs of w, h, subX, subY, bitDepth, numPlanes, and mcIdentity.
(This process modifies the output arrays OutY, OutU, OutV).</p>
   <p>Finally, the frame to be output is defined to be the arrays OutY, OutU, OutV where the bit depth for each sample is bitDepth.</p>
   <p>This frame to be output is the overall output of the decoding process and further processing (such as color conversion) is outside the scope of this specification.</p>
   <p>For example, a real implementation might use these arrays to display the frame to the user, or a test system might save the arrays so the output can be verified.</p>
   <p class="note" role="note"><span class="marker">Note:</span> If numPlanes is equal to 1, then the U and V planes should be ignored.</p>
   <h4 class="heading settled" data-level="7.20.2" id="intermediate_output_preparation_process"><span class="secno">7.20.2. </span><span class="content">Intermediate output preparation process</span><a class="self-link" href="#intermediate_output_preparation_process"></a></h4>
   <p>The input to this process is a variable frameToShowMapIdx specifying
which frame to output.</p>
   <p>The outputs of this process are the variables bitDepth, w, h, subX, subY, filmGrainPresent, numPlanes, and mcIdentity describing the format of the data in arrays OutY, OutU,
and OutV.</p>
   <p>If frameToShowMapIdx is greater than or equal to 0, then the decoder should set variables and copy OutY, OutU, and OutV from a previously decoded frame as follows:</p>
   <ul>
    <li data-md>
     <p>The variable w is set equal to RefCropWidth[ frameToShowMapIdx ].</p>
    <li data-md>
     <p>The variable h is set equal to RefCropHeight[ frameToShowMapIdx ].</p>
    <li data-md>
     <p>The variable left is set equal to RefCropLeft[ frameToShowMapIdx ].</p>
    <li data-md>
     <p>The variable top is set equal to RefCropTop[ frameToShowMapIdx ].</p>
    <li data-md>
     <p>The variable subX is set equal to RefSubsamplingX[ frameToShowMapIdx ].</p>
    <li data-md>
     <p>The variable subY is set equal to RefSubsamplingY[ frameToShowMapIdx ].</p>
    <li data-md>
     <p>The array OutY is w samples across by h samples down and the sample at location x samples across and y samples down is given by <code>OutY[ y ][ x ] = FrameStore[ frameToShowMapIdx ][ 0 ][ y + top ][ x + left ]</code> with x = 0..w - 1 and y = 0..h - 1.</p>
    <li data-md>
     <p>The array OutU is <code>(w + subX) >> subX</code> samples across by <code>(h + subY) >> subY</code> samples down and the sample at location x samples across and y samples down is given by <code>OutU[ y ][ x ] = FrameStore[ frameToShowMapIdx ][ 1 ][ y + (top >> subY) ][ x + (left >> subX) ]</code> with <code>x = 0..((w + subX) >> subX) - 1</code> and <code>y = 0..((h + subY) >> subY) - 1</code>.</p>
    <li data-md>
     <p>The array OutV is <code>(w + subX) >> subX</code> samples across by <code>(h + subY) >> subY</code> samples down and the sample at location x samples across and y samples down is given by <code>OutV[ y ][ x ] = FrameStore[ frameToShowMapIdx ][ 2 ][ y + (top >> subY) ][ x + (left >> subX) ]</code> with <code>x = 0..((w + subX) >> subX) - 1</code> and <code>y = 0..((h + subY) >> subY) - 1</code>.</p>
    <li data-md>
     <p>The variable bitDepth is set equal to RefBitDepth[ frameToShowMapIdx ].</p>
    <li data-md>
     <p>The variable numPlanes is set equal to RefNumPlanes[ frameToShowMapIdx ].</p>
    <li data-md>
     <p>The variable filmGrainPresent is set equal to RefFilmGrainPresent[ frameToShowMapIdx ].</p>
    <li data-md>
     <p>If filmGrainPresent is equal to 1, the function load_grain_params is invoked with frameToShowMapIdx as input (see <a href="#film_grain_params_semantics">§ 6.13.22 Film grain params semantics</a>).</p>
    <li data-md>
     <p>The variable mcIdentity is set equal to RefMatrixCoefficients[ frameToShowMapIdx ] == MC_IDENTITY.</p>
   </ul>
   <p>Otherwise (frameToShowMapIdx is equal to -1), then the decoder should set variables and copy the current frame as follows:</p>
   <ul>
    <li data-md>
     <p>The variable w is set equal to CropWidth.</p>
    <li data-md>
     <p>The variable h is set equal to CropHeight.</p>
    <li data-md>
     <p>The variable subX is set equal to SubsamplingX.</p>
    <li data-md>
     <p>The variable subY is set equal to SubsamplingY.</p>
    <li data-md>
     <p>The array OutY is w samples across by h samples down and the sample at location x samples across and y samples down is given by <code>OutY[ y ][ x ] = LrFrame[ 0 ][ y + CropTop ][ x + CropLeft ]</code> with x = 0..w - 1 and y = 0..h - 1.</p>
    <li data-md>
     <p>The array OutU is <code>(w + subX) >> subX</code> samples across by <code>(h + subY) >> subY</code> samples down and the sample at location x samples across and y samples down is given by <code>OutU[ y ][ x ] = LrFrame[ 1 ][ y + (CropTop >> subY) ][ x + (CropLeft >> subX) ]</code> with <code>x = 0..((w + subX) >> subX) - 1</code> and <code>y = 0..((h + subY) >> subY) - 1</code>.</p>
    <li data-md>
     <p>The array OutV is <code>(w + subX) >> subX</code> samples across by <code>(h + subY) >> subY</code> samples down and the sample at location x samples across and y samples down is given by <code>OutV[ y ][ x ] = LrFrame[ 2 ][ y + (CropTop >> subY) ][ x + (CropLeft >> subX) ]</code> with <code>x = 0..((w + subX) >> subX) - 1</code> and <code>y = 0..((h + subY) >> subY) - 1</code>.</p>
    <li data-md>
     <p>The variable bitDepth is set equal to BitDepth.</p>
    <li data-md>
     <p>The variable numPlanes is set equal to NumPlanes.</p>
    <li data-md>
     <p>The variable filmGrainPresent is set equal to film_grain_params_present.</p>
    <li data-md>
     <p>If filmGrainPresent is equal to 1, the function load_grain_params is invoked with NUM_REF_FRAMES as input (see <a href="#film_grain_params_semantics">§ 6.13.22 Film grain params semantics</a>).</p>
    <li data-md>
     <p>The variable mcIdentity is set equal to matrix_coefficients == MC_IDENTITY.</p>
   </ul>
   <p>The output of this process are the variables bitDepth, w, h, subX, subY, filmGrainPresent, numPlanes, and mcIdentity.</p>
   <h4 class="heading settled" data-level="7.20.3" id="output_successive_frames_process"><span class="secno">7.20.3. </span><span class="content">Output successive frames process</span><a class="self-link" href="#output_successive_frames_process"></a></h4>
   <p>The input to this process is a variable orderHint specifying the order hint (with additional bits for the embedded layer) for the current frame.</p>
   <p>This process outputs additional frame buffers if they have successive order hints.</p>
   <p>The variable k is set equal to 1.</p>
   <p>While k is less than or equal to NumRefFrames, the following ordered steps apply:</p>
   <ol>
    <li data-md>
     <p>The output showable frame process specified in <a href="#output_showable_frame_process">§ 7.20.4 Output showable frame process</a> is invoked with orderHint + k as input, and the output is assigned to the variable madeOutput.</p>
    <li data-md>
     <p>If madeOutput is equal to 0, the process immediately terminates.</p>
    <li data-md>
     <p>The variable k is incremented by 1.</p>
   </ol>
   <h4 class="heading settled" data-level="7.20.4" id="output_showable_frame_process"><span class="secno">7.20.4. </span><span class="content">Output showable frame process</span><a class="self-link" href="#output_showable_frame_process"></a></h4>
   <p>The input to this process is the variable targetHint.</p>
   <p>The process examines the frames in the frame buffer and outputs any showable frames
that match the target order hint as follows:</p>
<pre class="language-cpp highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>madeOutput</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="2"></span><span class="line"><c- k>for</c-><c- p>(</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>&lt;</c-> <c- n>NumRefFrames</c-><c- p>;</c-> <c- n>i</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="3"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>output_ordering</c-><c- p>(</c-><c- n>i</c-><c- p>)</c-> <c- o>==</c-> <c- n>targetHint</c-> <c- o>&amp;&amp;</c-> </span><span class="line-no" data-line="4"></span><span class="line">         <c- n>is_frame_eligible_for_output</c-><c- p>(</c-><c- n>i</c-><c- p>)</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="5"></span><span class="line">        <c- n>output</c-><c- p>(</c-> <c- n>i</c-> <c- p>)</c-></span><span class="line-no" data-line="6"></span><span class="line">        <c- n>madeOutput</c-> <c- o>=</c-> <c- mi>1</c-></span><span class="line-no" data-line="7"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="8"></span><span class="line"><c- p>}</c-></span></pre>
   <p>the function is_frame_eligible_for_output(refIdx) is specified as follows:</p>
   <ul>
    <li data-md>
     <p>RefShowableFrame[ refIdx ] has been written and is equal to 1 and RefValid[ refIdx ] is equal to 1 and the frame has not already been output by the output process specified in <a href="#output_process">§ 7.20 Output process</a>, the function returns 1.</p>
    <li data-md>
     <p>Otherwise (RefShowableFrame[ refIdx ] is equal to 0, or RefValid[ refIdx ] is equal to 0, or the frame has already been output), the function returns 0.</p>
   </ul>
   <p class="note" role="note"><span class="marker">Note:</span> The requirement that RefShowableFrame[ refIdx ] has been written prevents the use of uninitialized frame buffers when the first keyframe is decoded.
This could also be implemented by initializing the array RefShowableFrame to 0 before decoding starts.  However, note that later key frames in a video
may trigger the output of frames.</p>
   <p class="note" role="note"><span class="marker">Note:</span> Even if a frame is stored into multiple reference frame buffers,
it is still only eligible to be output once.</p>
   <p class="note" role="note"><span class="marker">Note:</span> Forward keyframes are not supported when using successive frame output.
If a forward keyframe is shown by this process, the usual side effects
of a forward keyframe are not applied.</p>
   <p>The output of this process is the variable madeOutput indicating
if a matching frame was output.</p>
   <h4 class="heading settled" data-level="7.20.5" id="flush_showable_frames_process"><span class="secno">7.20.5. </span><span class="content">Flush showable frames process</span><a class="self-link" href="#flush_showable_frames_process"></a></h4>
   <p>This process is invoked after all other OBUs have been decoded and outputs
all remaining eligible frames.</p>
   <p>An eligible frame is found as follows:</p>
<pre class="language-cpp highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>outputHint</c-> <c- o>=</c-> <c- mi>-1</c-></span><span class="line-no" data-line="2"></span><span class="line"><c- n>outIdx</c-> <c- o>=</c-> <c- mi>-1</c-></span><span class="line-no" data-line="3"></span><span class="line"><c- k>for</c-><c- p>(</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>&lt;</c-> <c- n>NUM_REF_FRAMES</c-><c- p>;</c-> <c- n>i</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="4"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>is_frame_eligible_for_output</c-><c- p>(</c-><c- n>i</c-><c- p>)</c-> <c- o>&amp;&amp;</c-> </span><span class="line-no" data-line="5"></span><span class="line">         <c- p>(</c-><c- n>outIdx</c-> <c- o>==</c-> <c- mi>-1</c-> <c- o>||</c-> <c- n>RefOrderHint</c-><c- p>[</c-><c- n>i</c-><c- p>]</c-> <c- o>&lt;=</c-> <c- n>outputHint</c-><c- p>)</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="6"></span><span class="line">        <c- n>outIdx</c-> <c- o>=</c-> <c- n>i</c-></span><span class="line-no" data-line="7"></span><span class="line">        <c- n>outputHint</c-> <c- o>=</c-> <c- n>RefOrderHint</c-><c- p>[</c-><c- n>i</c-><c- p>]</c-></span><span class="line-no" data-line="8"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="9"></span><span class="line"><c- p>}</c-></span></pre>
   <p>If outIdx is equal to -1, this process immediately terminates.</p>
   <p>The output process specified in <a href="#output_process">§ 7.20 Output process</a> is invoked with outIdx as input.</p>
   <p>This entire process is then repeated until one of the termination conditions is reached.</p>
   <h4 class="heading settled" data-level="7.20.6" id="output_frame_buffers_process"><span class="secno">7.20.6. </span><span class="content">Output frame buffers process</span><a class="self-link" href="#output_frame_buffers_process"></a></h4>
   <p>The input to this process is a variable refIdx.  If refIdx is greater
than or equal to 0, refIdx specifies which reference frame buffer
to output.  If refIdx is equal to -1, it indicates that the current
frame is output.</p>
   <p>First any eligible frames with lower order hints are output as follows:</p>
<pre class="language-cpp highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- k>while</c-><c- p>(</c-><c- mi>1</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- n>outputHint</c-> <c- o>=</c-> <c- n>output_ordering</c-><c- p>(</c-> <c- n>refIdx</c-> <c- p>)</c-></span><span class="line-no" data-line="3"></span><span class="line">    <c- n>outIdx</c-> <c- o>=</c-> <c- n>refIdx</c-></span><span class="line-no" data-line="4"></span><span class="line">    <c- k>for</c-> <c- p>(</c-><c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>&lt;</c-> <c- n>NumRefFrames</c-><c- p>;</c-> <c- n>i</c-><c- o>++</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="5"></span><span class="line">        <c- k>if</c-> <c- p>(</c-> <c- n>is_frame_eligible_for_output</c-><c- p>(</c-><c- n>i</c-><c- p>)</c-> <c- o>&amp;&amp;</c-></span><span class="line-no" data-line="6"></span><span class="line">             <c- n>output_ordering</c-><c- p>(</c-><c- n>i</c-><c- p>)</c-> <c- o>&lt;</c-> <c- n>outputHint</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="7"></span><span class="line">            <c- n>outIdx</c-> <c- o>=</c-> <c- n>i</c-></span><span class="line-no" data-line="8"></span><span class="line">            <c- n>outputHint</c-> <c- o>=</c-> <c- n>output_ordering</c-><c- p>(</c-><c- n>i</c-><c- p>)</c-></span><span class="line-no" data-line="9"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="10"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="11"></span><span class="line">    <c- k>if</c-> <c- p>(</c-><c- n>outIdx</c-> <c- o>==</c-> <c- n>refIdx</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="12"></span><span class="line">        <c- k>break</c-></span><span class="line-no" data-line="13"></span><span class="line">    <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="14"></span><span class="line">        <c- n>output</c-><c- p>(</c-><c- n>outIdx</c-><c- p>)</c-></span><span class="line-no" data-line="15"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="16"></span><span class="line"><c- p>}</c-></span></pre>
   <p>where the function output_ordering (which returns an order hint with additional bits specifying the embedded layer) is specified as:</p>
<pre class="language-cpp highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>output_ordering</c-><c- p>(</c-> <c- n>i</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- k>if</c-> <c- p>(</c-><c- n>i</c-> <c- o>&lt;</c-> <c- mi>0</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="3"></span><span class="line">        <c- k>return</c-> <c- n>OrderHint</c-> <c- o>*</c-> <c- p>(</c-><c- n>max_mlayer_id</c-> <c- o>+</c-> <c- mi>1</c-><c- p>)</c-> <c- o>+</c-> <c- n>obu_mlayer_id</c-></span><span class="line-no" data-line="4"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="5"></span><span class="line">    <c- k>return</c-> <c- n>RefOrderHint</c-><c- p>[</c-><c- n>i</c-><c- p>]</c-> <c- o>*</c-> <c- p>(</c-><c- n>max_mlayer_id</c-> <c- o>+</c-> <c- mi>1</c-><c- p>)</c-> <c- o>+</c-> <c- n>RefMLayerId</c-><c- p>[</c-><c- n>i</c-><c- p>]</c-></span><span class="line-no" data-line="6"></span><span class="line"><c- p>}</c-></span></pre>
   <p>The output process specified in <a href="#output_process">§ 7.20 Output process</a> is invoked with refIdx as input.</p>
   <p>The output successive frames process specified in <a href="#output_successive_frames_process">§ 7.20.3 Output successive frames process</a> is invoked
with output_ordering(-1) as input.</p>
   <h4 class="heading settled" data-level="7.20.7" id="film_grain_synthesis_process"><span class="secno">7.20.7. </span><span class="content">Film grain synthesis process</span><a class="self-link" href="#film_grain_synthesis_process"></a></h4>
   <h5 class="heading settled" data-level="7.20.7.1" id="fgsp_general"><span class="secno">7.20.7.1. </span><span class="content">General</span><a class="self-link" href="#fgsp_general"></a></h5>
   <p>The inputs to this process are:</p>
   <ul>
    <li data-md>
     <p>variables w and h specifying the width and height of the frame,</p>
    <li data-md>
     <p>variables subX and subY specifying the subsampling parameters of the frame,</p>
    <li data-md>
     <p>a variable bitDepth specifying the number of bits per sample,</p>
    <li data-md>
     <p>a variable numPlanes specifying the number of planes in the frame,</p>
    <li data-md>
     <p>a variable mcIdentity specifying if the MC_IDENTITY matrix was used.</p>
   </ul>
   <p>The process modifies the arrays OutY, OutU, OutV to add film grain noise by the following ordered steps:</p>
   <ol>
    <li data-md>
     <p>The variable RandomRegister (used for generating pseudo-random numbers) is set equal to grain_seed.</p>
    <li data-md>
     <p>The variable GrainCenter is set equal to <code>128 &lt;&lt; (bitDepth - 8)</code>.</p>
    <li data-md>
     <p>The variable GrainMin is set equal to -GrainCenter.</p>
    <li data-md>
     <p>The variable GrainMax is set equal to <code>(256 &lt;&lt; (bitDepth - 8)) - 1 - GrainCenter</code>.</p>
    <li data-md>
     <p>The generate grain process specified in <a href="#generate_grain_process">§ 7.20.7.3 Generate grain process</a> is invoked with subX, subY, and bitDepth as input.</p>
    <li data-md>
     <p>The scaling lookup initialization process specified in <a href="#scaling_lookup_initialization_process">§ 7.20.7.4 Scaling lookup initialization process</a> is invoked with numPlanes as input.</p>
    <li data-md>
     <p>The add noise process specified in <a href="#add_noise_synthesis_process">§ 7.20.7.5 Add noise synthesis process</a> is invoked with w, h, subX, subY, bitDepth, numPlanes, and mcIdentity as inputs.</p>
   </ol>
   <h5 class="heading settled" data-level="7.20.7.2" id="random_number_process"><span class="secno">7.20.7.2. </span><span class="content">Random number process</span><a class="self-link" href="#random_number_process"></a></h5>
   <p>The input to this process is a variable bits specifying the number of random bits to return.</p>
   <p>The output of this process is a pseudo-random number based on the state in RandomRegister.</p>
   <p>The process is specified as follows:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>get_random_number</c-><c- p>(</c-> <c- n>bits</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">  <c- n>r</c-> <c- o>=</c-> <c- n>RandomRegister</c-></span><span class="line-no" data-line="3"></span><span class="line">  <c- n>bit</c-> <c- o>=</c-> <c- p>((</c-><c- n>r</c-> <c- o>>></c-> <c- mi>0</c-><c- p>)</c-> <c- o>^</c-> <c- p>(</c-><c- n>r</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- o>^</c-> <c- p>(</c-><c- n>r</c-> <c- o>>></c-> <c- mi>3</c-><c- p>)</c-> <c- o>^</c-> <c- p>(</c-><c- n>r</c-> <c- o>>></c-> <c- mi>12</c-><c- p>))</c-> <c- o>&amp;</c-> <c- mi>1</c-></span><span class="line-no" data-line="4"></span><span class="line">  <c- n>r</c-> <c- o>=</c-> <c- p>(</c-><c- n>r</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- o>|</c-> <c- p>(</c-><c- n>bit</c-> <c- o>&lt;&lt;</c-> <c- mi>15</c-><c- p>)</c-></span><span class="line-no" data-line="5"></span><span class="line">  <c- n>result</c-> <c- o>=</c-> <c- p>(</c-><c- n>r</c-> <c- o>>></c-> <c- p>(</c-><c- mi>16</c-> <c- o>-</c-> <c- n>bits</c-><c- p>))</c-> <c- o>&amp;</c-> <c- p>((</c-><c- mi>1</c-> <c- o>&lt;&lt;</c-> <c- n>bits</c-><c- p>)</c-> <c- o>-</c-> <c- mi>1</c-><c- p>)</c-></span><span class="line-no" data-line="6"></span><span class="line">  <c- n>RandomRegister</c-> <c- o>=</c-> <c- n>r</c-></span><span class="line-no" data-line="7"></span><span class="line">  <c- k>return</c-> <c- n>result</c-></span><span class="line-no" data-line="8"></span><span class="line"><c- p>}</c-></span></pre>
   <p>The output of this process is the variable result.</p>
   <h5 class="heading settled" data-level="7.20.7.3" id="generate_grain_process"><span class="secno">7.20.7.3. </span><span class="content">Generate grain process</span><a class="self-link" href="#generate_grain_process"></a></h5>
   <p>The inputs to this process are:</p>
   <ul>
    <li data-md>
     <p>variables subX and subY specifying the subsampling parameters of the frame,</p>
    <li data-md>
     <p>a variable bitDepth specifying the number of bits per sample.</p>
   </ul>
   <p>This process generates noise via an auto-regressive filter.</p>
   <p>First an array LumaGrain 82 samples wide and 73 samples high of white noise is generated for luma as follows:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>shift</c-> <c- o>=</c-> <c- mi>12</c-> <c- o>-</c-> <c- n>bitDepth</c-> <c- o>+</c-> <c- n>grain_scale_shift</c-></span><span class="line-no" data-line="2"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>y</c-> <c- o>&lt;</c-> <c- mi>73</c-><c- p>;</c-> <c- n>y</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="3"></span><span class="line">  <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- mi>82</c-><c- p>;</c-> <c- n>x</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="4"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>num_y_points</c-> <c- o>></c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="5"></span><span class="line">      <c- n>g</c-> <c- o>=</c-> <c- n>Gaussian_Sequence</c-><c- p>[</c-> <c- n>get_random_number</c-><c- p>(</c-> <c- mi>11</c-> <c- p>)</c-> <c- p>]</c-></span><span class="line-no" data-line="6"></span><span class="line">    <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="7"></span><span class="line">      <c- n>g</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="8"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="9"></span><span class="line">    <c- n>LumaGrain</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Round2</c-><c- p>(</c-> <c- n>g</c-><c- p>,</c-> <c- n>shift</c-> <c- p>)</c-></span><span class="line-no" data-line="10"></span><span class="line">  <c- p>}</c-></span><span class="line-no" data-line="11"></span><span class="line"><c- p>}</c-></span></pre>
   <p>where the function call get_random_number invokes the random number process specified in <a href="#random_number_process">§ 7.20.7.2 Random number process</a>.</p>
   <p>Then an auto-regressive filter is applied to the white noise as follows:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>shift</c-> <c- o>=</c-> <c- n>ar_coeff_shift_minus_6</c-> <c- o>+</c-> <c- mi>6</c-></span><span class="line-no" data-line="2"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c-> <c- n>y</c-> <c- o>&lt;</c-> <c- mi>73</c-><c- p>;</c-> <c- n>y</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="3"></span><span class="line">  <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- mi>82</c-> <c- o>-</c-> <c- mi>3</c-><c- p>;</c-> <c- n>x</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="4"></span><span class="line">    <c- n>s</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="5"></span><span class="line">    <c- n>pos</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="6"></span><span class="line">    <c- k>for</c-> <c- p>(</c-> <c- n>deltaRow</c-> <c- o>=</c-> <c- o>-</c-><c- n>ar_coeff_lag</c-><c- p>;</c-> <c- n>deltaRow</c-> <c- o>&lt;=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>deltaRow</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="7"></span><span class="line">      <c- k>for</c-> <c- p>(</c-> <c- n>deltaCol</c-> <c- o>=</c-> <c- o>-</c-><c- n>ar_coeff_lag</c-><c- p>;</c-> <c- n>deltaCol</c-> <c- o>&lt;=</c-> <c- n>ar_coeff_lag</c-><c- p>;</c-> <c- n>deltaCol</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="8"></span><span class="line">        <c- k>if</c-> <c- p>(</c-> <c- n>deltaRow</c-> <c- o>==</c-> <c- mi>0</c-> <c- o>&amp;&amp;</c-> <c- n>deltaCol</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>)</c-></span><span class="line-no" data-line="9"></span><span class="line">          <c- k>break</c-></span><span class="line-no" data-line="10"></span><span class="line">        <c- n>c</c-> <c- o>=</c-> <c- n>ar_coeffs_y_plus_128</c-><c- p>[</c-> <c- n>pos</c-> <c- p>]</c-> <c- o>-</c-> <c- mi>128</c-></span><span class="line-no" data-line="11"></span><span class="line">        <c- n>s</c-> <c- o>+=</c-> <c- n>LumaGrain</c-><c- p>[</c-> <c- n>y</c-> <c- o>+</c-> <c- n>deltaRow</c-> <c- p>][</c-> <c- n>x</c-> <c- o>+</c-> <c- n>deltaCol</c-> <c- p>]</c-> <c- o>*</c-> <c- n>c</c-></span><span class="line-no" data-line="12"></span><span class="line">        <c- n>pos</c-><c- o>++</c-></span><span class="line-no" data-line="13"></span><span class="line">      <c- p>}</c-></span><span class="line-no" data-line="14"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="15"></span><span class="line">    <c- n>LumaGrain</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- n>GrainMin</c-><c- p>,</c-> <c- n>GrainMax</c-><c- p>,</c-> </span><span class="line-no" data-line="16"></span><span class="line">                                 <c- n>LumaGrain</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>+</c-> <c- n>Round2</c-><c- p>(</c-> <c- n>s</c-><c- p>,</c-> <c- n>shift</c-> <c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="17"></span><span class="line">  <c- p>}</c-></span><span class="line-no" data-line="18"></span><span class="line"><c- p>}</c-></span></pre>
   <p>The variable chromaW (representing the width of the chroma noise array) is set equal to (subX ? 44 : 82).</p>
   <p>The variable chromaH (representing the height of the chroma noise array) is set equal to (subY ? 38 : 73).</p>
   <p>White noise arrays CbGrain and CrGrain chromaW samples wide and chromaH samples high are generated as follows:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>shift</c-> <c- o>=</c-> <c- mi>12</c-> <c- o>-</c-> <c- n>bitDepth</c-> <c- o>+</c-> <c- n>grain_scale_shift</c-></span><span class="line-no" data-line="2"></span><span class="line"><c- n>RandomRegister</c-> <c- o>=</c-> <c- n>grain_seed</c-> <c- o>^</c-> <c- mh>0xb524</c-></span><span class="line-no" data-line="3"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>y</c-> <c- o>&lt;</c-> <c- n>chromaH</c-><c- p>;</c-> <c- n>y</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="4"></span><span class="line">  <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- n>chromaW</c-><c- p>;</c-> <c- n>x</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="5"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>num_cb_points</c-> <c- o>></c-> <c- mi>0</c-> <c- o>||</c-> <c- n>chroma_scaling_from_luma</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="6"></span><span class="line">      <c- n>g</c-> <c- o>=</c-> <c- n>Gaussian_Sequence</c-><c- p>[</c-> <c- n>get_random_number</c-><c- p>(</c-> <c- mi>11</c-> <c- p>)</c-> <c- p>]</c-></span><span class="line-no" data-line="7"></span><span class="line">    <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="8"></span><span class="line">      <c- n>g</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="9"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="10"></span><span class="line">    <c- n>CbGrain</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Round2</c-><c- p>(</c-> <c- n>g</c-><c- p>,</c-> <c- n>shift</c-> <c- p>)</c-></span><span class="line-no" data-line="11"></span><span class="line">  <c- p>}</c-></span><span class="line-no" data-line="12"></span><span class="line"><c- p>}</c-></span><span class="line-no" data-line="13"></span><span class="line"><c- n>RandomRegister</c-> <c- o>=</c-> <c- n>grain_seed</c-> <c- o>^</c-> <c- mh>0x49d8</c-></span><span class="line-no" data-line="14"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>y</c-> <c- o>&lt;</c-> <c- n>chromaH</c-><c- p>;</c-> <c- n>y</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="15"></span><span class="line">  <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- n>chromaW</c-><c- p>;</c-> <c- n>x</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="16"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>num_cr_points</c-> <c- o>></c-> <c- mi>0</c-> <c- o>||</c-> <c- n>chroma_scaling_from_luma</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="17"></span><span class="line">      <c- n>g</c-> <c- o>=</c-> <c- n>Gaussian_Sequence</c-><c- p>[</c-> <c- n>get_random_number</c-><c- p>(</c-> <c- mi>11</c-> <c- p>)</c-> <c- p>]</c-></span><span class="line-no" data-line="18"></span><span class="line">    <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="19"></span><span class="line">      <c- n>g</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="20"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="21"></span><span class="line">    <c- n>CrGrain</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Round2</c-><c- p>(</c-> <c- n>g</c-><c- p>,</c-> <c- n>shift</c-> <c- p>)</c-></span><span class="line-no" data-line="22"></span><span class="line">  <c- p>}</c-></span><span class="line-no" data-line="23"></span><span class="line"><c- p>}</c-></span></pre>
   <p>Then the auto-regressive filter is applied as follows:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>shift</c-> <c- o>=</c-> <c- n>ar_coeff_shift_minus_6</c-> <c- o>+</c-> <c- mi>6</c-></span><span class="line-no" data-line="2"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c-> <c- n>y</c-> <c- o>&lt;</c-> <c- n>chromaH</c-><c- p>;</c-> <c- n>y</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="3"></span><span class="line">  <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- n>chromaW</c-> <c- o>-</c-> <c- mi>3</c-><c- p>;</c-> <c- n>x</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="4"></span><span class="line">    <c- n>s0</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="5"></span><span class="line">    <c- n>s1</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="6"></span><span class="line">    <c- n>pos</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="7"></span><span class="line">    <c- k>for</c-> <c- p>(</c-> <c- n>deltaRow</c-> <c- o>=</c-> <c- o>-</c-><c- n>ar_coeff_lag</c-><c- p>;</c-> <c- n>deltaRow</c-> <c- o>&lt;=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>deltaRow</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="8"></span><span class="line">      <c- k>for</c-> <c- p>(</c-> <c- n>deltaCol</c-> <c- o>=</c-> <c- o>-</c-><c- n>ar_coeff_lag</c-><c- p>;</c-> <c- n>deltaCol</c-> <c- o>&lt;=</c-> <c- n>ar_coeff_lag</c-><c- p>;</c-> <c- n>deltaCol</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="9"></span><span class="line">        <c- n>c0</c-> <c- o>=</c-> <c- n>ar_coeffs_cb_plus_128</c-><c- p>[</c-> <c- n>pos</c-> <c- p>]</c-> <c- o>-</c-> <c- mi>128</c-></span><span class="line-no" data-line="10"></span><span class="line">        <c- n>c1</c-> <c- o>=</c-> <c- n>ar_coeffs_cr_plus_128</c-><c- p>[</c-> <c- n>pos</c-> <c- p>]</c-> <c- o>-</c-> <c- mi>128</c-></span><span class="line-no" data-line="11"></span><span class="line">        <c- k>if</c-> <c- p>(</c-> <c- n>deltaRow</c-> <c- o>==</c-> <c- mi>0</c-> <c- o>&amp;&amp;</c-> <c- n>deltaCol</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="12"></span><span class="line">          <c- k>if</c-> <c- p>(</c-> <c- n>num_y_points</c-> <c- o>></c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="13"></span><span class="line">            <c- n>luma</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="14"></span><span class="line">            <c- n>lumaX</c-> <c- o>=</c-> <c- p>(</c-> <c- p>(</c-><c- n>x</c-> <c- o>-</c-> <c- mi>3</c-><c- p>)</c-> <c- o>&lt;&lt;</c-> <c- n>subX</c-> <c- p>)</c-> <c- o>+</c-> <c- mi>3</c-></span><span class="line-no" data-line="15"></span><span class="line">            <c- n>lumaY</c-> <c- o>=</c-> <c- p>(</c-> <c- p>(</c-><c- n>y</c-> <c- o>-</c-> <c- mi>3</c-><c- p>)</c-> <c- o>&lt;&lt;</c-> <c- n>subY</c-> <c- p>)</c-> <c- o>+</c-> <c- mi>3</c-></span><span class="line-no" data-line="16"></span><span class="line">            <c- k>for</c-> <c- p>(</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>&lt;=</c-> <c- n>subY</c-><c- p>;</c-> <c- n>i</c-><c- o>++</c-> <c- p>)</c-></span><span class="line-no" data-line="17"></span><span class="line">              <c- k>for</c-> <c- p>(</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>j</c-> <c- o>&lt;=</c-> <c- n>subX</c-><c- p>;</c-> <c- n>j</c-><c- o>++</c-> <c- p>)</c-></span><span class="line-no" data-line="18"></span><span class="line">                <c- n>luma</c-> <c- o>+=</c-> <c- n>LumaGrain</c-><c- p>[</c-> <c- n>lumaY</c-> <c- o>+</c-> <c- n>i</c-> <c- p>][</c-> <c- n>lumaX</c-> <c- o>+</c-> <c- n>j</c-> <c- p>]</c-></span><span class="line-no" data-line="19"></span><span class="line">            <c- n>luma</c-> <c- o>=</c-> <c- n>Round2</c-><c- p>(</c-> <c- n>luma</c-><c- p>,</c-> <c- n>subX</c-> <c- o>+</c-> <c- n>subY</c-> <c- p>)</c-></span><span class="line-no" data-line="20"></span><span class="line">            <c- n>s0</c-> <c- o>+=</c-> <c- n>luma</c-> <c- o>*</c-> <c- n>c0</c-></span><span class="line-no" data-line="21"></span><span class="line">            <c- n>s1</c-> <c- o>+=</c-> <c- n>luma</c-> <c- o>*</c-> <c- n>c1</c-></span><span class="line-no" data-line="22"></span><span class="line">          <c- p>}</c-></span><span class="line-no" data-line="23"></span><span class="line">          <c- k>break</c-></span><span class="line-no" data-line="24"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="25"></span><span class="line">        <c- n>s0</c-> <c- o>+=</c-> <c- n>CbGrain</c-><c- p>[</c-> <c- n>y</c-> <c- o>+</c-> <c- n>deltaRow</c-> <c- p>][</c-> <c- n>x</c-> <c- o>+</c-> <c- n>deltaCol</c-> <c- p>]</c-> <c- o>*</c-> <c- n>c0</c-></span><span class="line-no" data-line="26"></span><span class="line">        <c- n>s1</c-> <c- o>+=</c-> <c- n>CrGrain</c-><c- p>[</c-> <c- n>y</c-> <c- o>+</c-> <c- n>deltaRow</c-> <c- p>][</c-> <c- n>x</c-> <c- o>+</c-> <c- n>deltaCol</c-> <c- p>]</c-> <c- o>*</c-> <c- n>c1</c-></span><span class="line-no" data-line="27"></span><span class="line">        <c- n>pos</c-><c- o>++</c-></span><span class="line-no" data-line="28"></span><span class="line">      <c- p>}</c-></span><span class="line-no" data-line="29"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="30"></span><span class="line">    <c- n>CbGrain</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- n>GrainMin</c-><c- p>,</c-> <c- n>GrainMax</c-><c- p>,</c-></span><span class="line-no" data-line="31"></span><span class="line">                               <c- n>CbGrain</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>+</c-> <c- n>Round2</c-><c- p>(</c-> <c- n>s0</c-><c- p>,</c-> <c- n>shift</c-> <c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="32"></span><span class="line">    <c- n>CrGrain</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- n>GrainMin</c-><c- p>,</c-> <c- n>GrainMax</c-><c- p>,</c-></span><span class="line-no" data-line="33"></span><span class="line">                               <c- n>CrGrain</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>+</c-> <c- n>Round2</c-><c- p>(</c-> <c- n>s1</c-><c- p>,</c-> <c- n>shift</c-> <c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="34"></span><span class="line">  <c- p>}</c-></span><span class="line-no" data-line="35"></span><span class="line"><c- p>}</c-></span></pre>
   <p class="note" role="note"><span class="marker">Note:</span> When num_y_points is equal to 0, this process may use uninitialized values within ar_coeffs_y_plus_128 to compute LumaGrain.
However, LumaGrain will never be read in this case so it does not matter what values are constucted.
Similarly, when num_cr_points/num_cb_points are equal to 0 and chroma_scaling_from_luma is equal to 0, the CbGrain/CrGrain arrays will never be read.</p>
   <h5 class="heading settled" data-level="7.20.7.4" id="scaling_lookup_initialization_process"><span class="secno">7.20.7.4. </span><span class="content">Scaling lookup initialization process</span><a class="self-link" href="#scaling_lookup_initialization_process"></a></h5>
   <p>The input to this process is a variable numPlanes specifying the number of planes in the frame.</p>
   <p>This process computes 3 lookup tables for the different color components.</p>
   <p>Each lookup table ScalingLut[ plane ] contains 256 entries constructed by a piecewise linear interpolation of the given points as follows:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>plane</c-> <c- o>&lt;</c-> <c- n>numPlanes</c-><c- p>;</c-> <c- n>plane</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>==</c-> <c- mi>0</c-> <c- o>||</c-> <c- n>chroma_scaling_from_luma</c-> <c- p>)</c-></span><span class="line-no" data-line="3"></span><span class="line">        <c- n>numPoints</c-> <c- o>=</c-> <c- n>num_y_points</c-></span><span class="line-no" data-line="4"></span><span class="line">    <c- k>else</c-> <c- k>if</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>==</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="5"></span><span class="line">        <c- n>numPoints</c-> <c- o>=</c-> <c- n>num_cb_points</c-></span><span class="line-no" data-line="6"></span><span class="line">    <c- k>else</c-></span><span class="line-no" data-line="7"></span><span class="line">        <c- n>numPoints</c-> <c- o>=</c-> <c- n>num_cr_points</c-></span><span class="line-no" data-line="8"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>numPoints</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="9"></span><span class="line">        <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- mi>256</c-><c- p>;</c-> <c- n>x</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="10"></span><span class="line">            <c- n>ScalingLut</c-><c- p>[</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="11"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="12"></span><span class="line">    <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="13"></span><span class="line">        <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- n>get_x</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- mi>0</c-> <c- p>);</c-> <c- n>x</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="14"></span><span class="line">            <c- n>ScalingLut</c-><c- p>[</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>get_y</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- mi>0</c-> <c- p>)</c-></span><span class="line-no" data-line="15"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="16"></span><span class="line">        <c- k>for</c-> <c- p>(</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>&lt;</c-> <c- n>numPoints</c-> <c- o>-</c-> <c- mi>1</c-><c- p>;</c-> <c- n>i</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="17"></span><span class="line">            <c- n>deltaY</c-> <c- o>=</c-> <c- n>get_y</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- n>i</c-> <c- o>+</c-> <c- mi>1</c-> <c- p>)</c-> <c- o>-</c-> <c- n>get_y</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- n>i</c-> <c- p>)</c-></span><span class="line-no" data-line="18"></span><span class="line">            <c- n>deltaX</c-> <c- o>=</c-> <c- n>get_x</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- n>i</c-> <c- o>+</c-> <c- mi>1</c-> <c- p>)</c-> <c- o>-</c-> <c- n>get_x</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- n>i</c-> <c- p>)</c-></span><span class="line-no" data-line="19"></span><span class="line">            <c- n>delta</c-> <c- o>=</c-> <c- n>deltaY</c-> <c- o>*</c-> <c- p>(</c-> <c- p>(</c-> <c- mi>65536</c-> <c- o>+</c-> <c- p>(</c-><c- n>deltaX</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>)</c-> <c- o>/</c-> <c- n>deltaX</c-> <c- p>)</c-></span><span class="line-no" data-line="20"></span><span class="line">            <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- n>deltaX</c-><c- p>;</c-> <c- n>x</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="21"></span><span class="line">                <c- n>v</c-> <c- o>=</c-> <c- n>get_y</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- n>i</c-> <c- p>)</c-> <c- o>+</c-> <c- p>(</c-> <c- p>(</c-> <c- n>x</c-> <c- o>*</c-> <c- n>delta</c-> <c- o>+</c-> <c- mi>32768</c-> <c- p>)</c-> <c- o>>></c-> <c- mi>16</c-> <c- p>)</c-></span><span class="line-no" data-line="22"></span><span class="line">                <c- n>ScalingLut</c-><c- p>[</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>get_x</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- n>i</c-> <c- p>)</c->  <c- o>+</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>v</c-></span><span class="line-no" data-line="23"></span><span class="line">            <c- p>}</c-></span><span class="line-no" data-line="24"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="25"></span><span class="line">        <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- n>get_x</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- n>numPoints</c-> <c- o>-</c-> <c- mi>1</c-> <c- p>);</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- mi>256</c-><c- p>;</c-> <c- n>x</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="26"></span><span class="line">            <c- n>ScalingLut</c-><c- p>[</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>get_y</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- n>numPoints</c-> <c- o>-</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="27"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="28"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="29"></span><span class="line"><c- p>}</c-></span></pre>
   <p>where the functions <code>get_x</code> and <code>get_y</code> return the coordinates for a specific point and are specified as:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>get_x</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- n>i</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>==</c-> <c- mi>0</c-> <c- o>||</c-> <c- n>chroma_scaling_from_luma</c-> <c- p>)</c-></span><span class="line-no" data-line="3"></span><span class="line">        <c- k>return</c-> <c- n>point_y_value</c-><c- p>[</c-> <c- n>i</c-> <c- p>]</c-></span><span class="line-no" data-line="4"></span><span class="line">    <c- k>else</c-> <c- k>if</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>==</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="5"></span><span class="line">        <c- k>return</c-> <c- n>point_cb_value</c-><c- p>[</c-> <c- n>i</c-> <c- p>]</c-></span><span class="line-no" data-line="6"></span><span class="line">    <c- k>else</c-></span><span class="line-no" data-line="7"></span><span class="line">        <c- k>return</c-> <c- n>point_cr_value</c-><c- p>[</c-> <c- n>i</c-> <c- p>]</c-></span><span class="line-no" data-line="8"></span><span class="line"><c- p>}</c-></span><span class="line-no" data-line="9"></span><span class="line"></span><span class="line-no" data-line="10"></span><span class="line"><c- n>get_y</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- n>i</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="11"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>==</c-> <c- mi>0</c-> <c- o>||</c-> <c- n>chroma_scaling_from_luma</c-> <c- p>)</c-></span><span class="line-no" data-line="12"></span><span class="line">        <c- k>return</c-> <c- n>point_y_scaling</c-><c- p>[</c-> <c- n>i</c-> <c- p>]</c-></span><span class="line-no" data-line="13"></span><span class="line">    <c- k>else</c-> <c- k>if</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>==</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="14"></span><span class="line">        <c- k>return</c-> <c- n>point_cb_scaling</c-><c- p>[</c-> <c- n>i</c-> <c- p>]</c-></span><span class="line-no" data-line="15"></span><span class="line">    <c- k>else</c-></span><span class="line-no" data-line="16"></span><span class="line">        <c- k>return</c-> <c- n>point_cr_scaling</c-><c- p>[</c-> <c- n>i</c-> <c- p>]</c-></span><span class="line-no" data-line="17"></span><span class="line"><c- p>}</c-></span></pre>
   <h5 class="heading settled" data-level="7.20.7.5" id="add_noise_synthesis_process"><span class="secno">7.20.7.5. </span><span class="content">Add noise synthesis process</span><a class="self-link" href="#add_noise_synthesis_process"></a></h5>
   <p>The inputs to this process are:</p>
   <ul>
    <li data-md>
     <p>variables w and h specifying the width and height of the frame,</p>
    <li data-md>
     <p>variables subX and subY specifying the subsampling parameters of the frame,</p>
    <li data-md>
     <p>a variable bitDepth specifying the number of bits per sample,</p>
    <li data-md>
     <p>a variable numPlanes specifying the number of planes in the frame,</p>
    <li data-md>
     <p>a variable mcIdentity specifying if the MC_IDENTITY matrix was used.</p>
   </ul>
   <p>This process combines the film grain with the image data.</p>
   <p>First an array of noise data noiseStripe is generated for each 32 luma sample high stripe of the image.</p>
   <p>noiseStripe[ lumaNum ][ 0 ] is 34 samples high and w samples wide
(a few additional samples across are actually written to the array, but these are never read) and contains noise for the luma <a data-link-type="dfn" href="#component" id="ref-for-component①⓪">component</a>.</p>
   <p>noiseStripe[ lumaNum ][ 1 ] and noiseStripe[ lumaNum ][ 2 ] are <code>(34 >> subY)</code> samples high and Round2(w, subX) samples wide and contain noise for the chroma components.</p>
   <p>noiseStripe represents the result of constructing square grain blocks and blending horizontally adjacent blocks together
(although blending is only applied if overlap_flag is equal to 1) and is constructed as follows:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>lumaSize</c-> <c- o>=</c-> <c- n>film_grain_block_size</c-> <c- o>?</c-> <c- mi>32</c-> <c- o>:</c-> <c- mi>16</c-></span><span class="line-no" data-line="2"></span><span class="line"><c- n>lumaNum</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="3"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>y</c-> <c- o>&lt;</c-> <c- p>(</c-><c- n>h</c-> <c- o>+</c-> <c- mi>1</c-><c- p>)</c-><c- o>/</c-><c- mi>2</c-> <c- p>;</c-> <c- n>y</c-> <c- o>+=</c-> <c- p>(</c-><c- n>lumaSize</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="4"></span><span class="line">  <c- n>RandomRegister</c-> <c- o>=</c-> <c- n>grain_seed</c-></span><span class="line-no" data-line="5"></span><span class="line">  <c- n>lumaRand</c-> <c- o>=</c-> <c- n>y</c-> <c- o>>></c-> <c- mi>3</c-></span><span class="line-no" data-line="6"></span><span class="line">  <c- n>RandomRegister</c-> <c- o>^=</c-> <c- p>((</c-><c- n>lumaRand</c-> <c- o>*</c-> <c- mi>37</c-> <c- o>+</c-> <c- mi>178</c-><c- p>)</c-> <c- o>&amp;</c-> <c- mi>255</c-><c- p>)</c-> <c- o>&lt;&lt;</c-> <c- mi>8</c-></span><span class="line-no" data-line="7"></span><span class="line">  <c- n>RandomRegister</c-> <c- o>^=</c-> <c- p>((</c-><c- n>lumaRand</c-> <c- o>*</c-> <c- mi>173</c-> <c- o>+</c-> <c- mi>105</c-><c- p>)</c-> <c- o>&amp;</c-> <c- mi>255</c-><c- p>)</c-></span><span class="line-no" data-line="8"></span><span class="line">  <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- p>(</c-><c- n>w</c-> <c- o>+</c-> <c- mi>1</c-><c- p>)</c-><c- o>/</c-><c- mi>2</c-> <c- p>;</c-> <c- n>x</c-> <c- o>+=</c-> <c- p>(</c-><c- n>lumaSize</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="9"></span><span class="line">    <c- n>offsetY</c-> <c- o>=</c-> <c- n>get_random_number</c-><c- p>(</c-> <c- mi>9</c-> <c- p>)</c-> <c- o>*</c-> <c- p>(</c-><c- mi>3</c-> <c- o>-</c-> <c- n>film_grain_block_size</c-><c- p>)</c-> <c- o>>></c-> <c- mi>6</c-></span><span class="line-no" data-line="10"></span><span class="line">    <c- n>get_random_number</c-><c- p>(</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="11"></span><span class="line">    <c- n>get_random_number</c-><c- p>(</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="12"></span><span class="line">    <c- n>get_random_number</c-><c- p>(</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="13"></span><span class="line">    <c- n>offsetX</c-> <c- o>=</c-> <c- n>get_random_number</c-><c- p>(</c-> <c- mi>9</c-> <c- p>)</c-> <c- o>*</c-> <c- p>(</c-><c- mi>3</c-> <c- o>-</c-> <c- n>film_grain_block_size</c-><c- p>)</c-> <c- o>>></c-> <c- mi>6</c-></span><span class="line-no" data-line="14"></span><span class="line">    <c- n>get_random_number</c-><c- p>(</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="15"></span><span class="line">    <c- n>get_random_number</c-><c- p>(</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="16"></span><span class="line">    <c- n>get_random_number</c-><c- p>(</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="17"></span><span class="line">    <c- k>for</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>=</c-> <c- mi>0</c-> <c- p>;</c-> <c- n>plane</c-> <c- o>&lt;</c-> <c- n>numPlanes</c-><c- p>;</c-> <c- n>plane</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="18"></span><span class="line">      <c- n>planeSubX</c-> <c- o>=</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>></c-> <c- mi>0</c-><c- p>)</c-> <c- o>?</c-> <c- n>subX</c-> <c- o>:</c-> <c- mi>0</c-></span><span class="line-no" data-line="19"></span><span class="line">      <c- n>planeSubY</c-> <c- o>=</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>></c-> <c- mi>0</c-><c- p>)</c-> <c- o>?</c-> <c- n>subY</c-> <c- o>:</c-> <c- mi>0</c-></span><span class="line-no" data-line="20"></span><span class="line">      <c- n>planeOffsetX</c-> <c- o>=</c-> <c- n>planeSubX</c-> <c- o>?</c-> <c- mi>6</c-> <c- o>+</c-> <c- n>offsetX</c-> <c- o>:</c-> <c- mi>9</c-> <c- o>+</c-> <c- n>offsetX</c-> <c- o>*</c-> <c- mi>2</c-></span><span class="line-no" data-line="21"></span><span class="line">      <c- n>planeOffsetY</c-> <c- o>=</c-> <c- n>planeSubY</c-> <c- o>?</c-> <c- mi>6</c-> <c- o>+</c-> <c- n>offsetY</c-> <c- o>:</c-> <c- mi>9</c-> <c- o>+</c-> <c- n>offsetY</c-> <c- o>*</c-> <c- mi>2</c-></span><span class="line-no" data-line="22"></span><span class="line">      <c- k>for</c-> <c- p>(</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>&lt;</c-> <c- p>(</c-><c- n>lumaSize</c-> <c- o>+</c-> <c- mi>2</c-><c- p>)</c-> <c- o>>></c-> <c- n>planeSubY</c-> <c- p>;</c-> <c- n>i</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="23"></span><span class="line">        <c- k>for</c-> <c- p>(</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>j</c-> <c- o>&lt;</c-> <c- p>(</c-><c- n>lumaSize</c-> <c- o>+</c-> <c- mi>2</c-><c- p>)</c-> <c- o>>></c-> <c- n>planeSubX</c-> <c- p>;</c-> <c- n>j</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="24"></span><span class="line">          <c- k>if</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>)</c-></span><span class="line-no" data-line="25"></span><span class="line">            <c- n>g</c-> <c- o>=</c-> <c- n>LumaGrain</c-><c- p>[</c-> <c- n>planeOffsetY</c-> <c- o>+</c-> <c- n>i</c-> <c- p>][</c-> <c- n>planeOffsetX</c-> <c- o>+</c-> <c- n>j</c-> <c- p>]</c-></span><span class="line-no" data-line="26"></span><span class="line">          <c- k>else</c-> <c- k>if</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>==</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="27"></span><span class="line">            <c- n>g</c-> <c- o>=</c-> <c- n>CbGrain</c-><c- p>[</c-> <c- n>planeOffsetY</c-> <c- o>+</c-> <c- n>i</c-> <c- p>][</c-> <c- n>planeOffsetX</c-> <c- o>+</c-> <c- n>j</c-> <c- p>]</c-></span><span class="line-no" data-line="28"></span><span class="line">          <c- k>else</c-></span><span class="line-no" data-line="29"></span><span class="line">            <c- n>g</c-> <c- o>=</c-> <c- n>CrGrain</c-><c- p>[</c-> <c- n>planeOffsetY</c-> <c- o>+</c-> <c- n>i</c-> <c- p>][</c-> <c- n>planeOffsetX</c-> <c- o>+</c-> <c- n>j</c-> <c- p>]</c-></span><span class="line-no" data-line="30"></span><span class="line">          <c- k>if</c-> <c- p>(</c-> <c- n>planeSubX</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="31"></span><span class="line">            <c- k>if</c-> <c- p>(</c-> <c- n>j</c-> <c- o>&lt;</c-> <c- mi>2</c-> <c- o>&amp;&amp;</c-> <c- n>overlap_flag</c-> <c- o>&amp;&amp;</c-> <c- n>x</c-> <c- o>></c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="32"></span><span class="line">              <c- n>old</c-> <c- o>=</c-> <c- n>noiseStripe</c-><c- p>[</c-> <c- n>lumaNum</c-> <c- p>][</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>i</c-> <c- p>][</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>2</c-> <c- o>+</c-> <c- n>j</c-> <c- p>]</c-></span><span class="line-no" data-line="33"></span><span class="line">              <c- k>if</c-> <c- p>(</c-> <c- n>j</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="34"></span><span class="line">                <c- n>g</c-> <c- o>=</c-> <c- n>old</c-> <c- o>*</c-> <c- mi>27</c-> <c- o>+</c-> <c- n>g</c-> <c- o>*</c-> <c- mi>17</c-></span><span class="line-no" data-line="35"></span><span class="line">              <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="36"></span><span class="line">                <c- n>g</c-> <c- o>=</c-> <c- n>old</c-> <c- o>*</c-> <c- mi>17</c-> <c- o>+</c-> <c- n>g</c-> <c- o>*</c-> <c- mi>27</c-></span><span class="line-no" data-line="37"></span><span class="line">              <c- p>}</c-></span><span class="line-no" data-line="38"></span><span class="line">              <c- n>g</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- n>GrainMin</c-><c- p>,</c-> <c- n>GrainMax</c-><c- p>,</c-> <c- n>Round2</c-><c- p>(</c-><c- n>g</c-><c- p>,</c-> <c- mi>5</c-><c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="39"></span><span class="line">            <c- p>}</c-></span><span class="line-no" data-line="40"></span><span class="line">            <c- n>noiseStripe</c-><c- p>[</c-> <c- n>lumaNum</c-> <c- p>][</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>i</c-> <c- p>][</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>2</c-> <c- o>+</c-> <c- n>j</c-> <c- p>]</c-> <c- o>=</c-> <c- n>g</c-></span><span class="line-no" data-line="41"></span><span class="line">          <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="42"></span><span class="line">            <c- k>if</c-> <c- p>(</c-> <c- n>j</c-> <c- o>==</c-> <c- mi>0</c-> <c- o>&amp;&amp;</c-> <c- n>overlap_flag</c-> <c- o>&amp;&amp;</c-> <c- n>x</c-> <c- o>></c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="43"></span><span class="line">              <c- n>old</c-> <c- o>=</c-> <c- n>noiseStripe</c-><c- p>[</c-> <c- n>lumaNum</c-> <c- p>][</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>i</c-> <c- p>][</c-> <c- n>x</c-> <c- o>+</c-> <c- n>j</c-> <c- p>]</c-></span><span class="line-no" data-line="44"></span><span class="line">              <c- n>g</c-> <c- o>=</c-> <c- n>old</c-> <c- o>*</c-> <c- mi>23</c-> <c- o>+</c-> <c- n>g</c-> <c- o>*</c-> <c- mi>22</c-></span><span class="line-no" data-line="45"></span><span class="line">              <c- n>g</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- n>GrainMin</c-><c- p>,</c-> <c- n>GrainMax</c-><c- p>,</c-> <c- n>Round2</c-><c- p>(</c-><c- n>g</c-><c- p>,</c-> <c- mi>5</c-><c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="46"></span><span class="line">            <c- p>}</c-></span><span class="line-no" data-line="47"></span><span class="line">            <c- n>noiseStripe</c-><c- p>[</c-> <c- n>lumaNum</c-> <c- p>][</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>i</c-> <c- p>][</c-> <c- n>x</c-> <c- o>+</c-> <c- n>j</c-> <c- p>]</c-> <c- o>=</c-> <c- n>g</c-></span><span class="line-no" data-line="48"></span><span class="line">          <c- p>}</c-></span><span class="line-no" data-line="49"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="50"></span><span class="line">      <c- p>}</c-></span><span class="line-no" data-line="51"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="52"></span><span class="line">  <c- p>}</c-></span><span class="line-no" data-line="53"></span><span class="line">  <c- n>lumaNum</c-><c- o>++</c-></span><span class="line-no" data-line="54"></span><span class="line"><c- p>}</c-></span></pre>
   <p>Then the noise stripes are blended together to form a noise image noiseImage as follows:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>plane</c-> <c- o>&lt;</c-> <c- n>numPlanes</c-><c- p>;</c-> <c- n>plane</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">  <c- n>planeSubX</c-> <c- o>=</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>></c-> <c- mi>0</c-><c- p>)</c-> <c- o>?</c-> <c- n>subX</c-> <c- o>:</c-> <c- mi>0</c-></span><span class="line-no" data-line="3"></span><span class="line">  <c- n>planeSubY</c-> <c- o>=</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>></c-> <c- mi>0</c-><c- p>)</c-> <c- o>?</c-> <c- n>subY</c-> <c- o>:</c-> <c- mi>0</c-></span><span class="line-no" data-line="4"></span><span class="line">  <c- k>for</c-> <c- p>(</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>y</c-> <c- o>&lt;</c-> <c- p>(</c-> <c- p>(</c-><c- n>h</c-> <c- o>+</c-> <c- n>planeSubY</c-><c- p>)</c-> <c- o>>></c-> <c- n>planeSubY</c-> <c- p>)</c-> <c- p>;</c-> <c- n>y</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="5"></span><span class="line">    <c- n>lumaNum</c-> <c- o>=</c-> <c- n>y</c-> <c- o>>></c-> <c- p>(</c-> <c- mi>4</c-> <c- o>+</c-> <c- n>film_grain_block_size</c-> <c- o>-</c-> <c- n>planeSubY</c-> <c- p>)</c-></span><span class="line-no" data-line="6"></span><span class="line">    <c- n>i</c-> <c- o>=</c-> <c- n>y</c-> <c- o>-</c-> <c- p>(</c-><c- n>lumaNum</c-> <c- o>&lt;&lt;</c-> <c- p>(</c-> <c- mi>4</c-> <c- o>+</c-> <c- n>film_grain_block_size</c-> <c- o>-</c-> <c- n>planeSubY</c-> <c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="7"></span><span class="line">    <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- p>(</c-> <c- p>(</c-><c- n>w</c-> <c- o>+</c-> <c- n>planeSubX</c-><c- p>)</c-> <c- o>>></c-> <c- n>planeSubX</c-><c- p>)</c-> <c- p>;</c-> <c- n>x</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="8"></span><span class="line">      <c- n>g</c-> <c- o>=</c-> <c- n>noiseStripe</c-><c- p>[</c-> <c- n>lumaNum</c-> <c- p>][</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>i</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-></span><span class="line-no" data-line="9"></span><span class="line">      <c- k>if</c-> <c- p>(</c-> <c- n>planeSubY</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="10"></span><span class="line">        <c- k>if</c-> <c- p>(</c-> <c- n>i</c-> <c- o>&lt;</c-> <c- mi>2</c-> <c- o>&amp;&amp;</c-> <c- n>lumaNum</c-> <c- o>></c-> <c- mi>0</c-> <c- o>&amp;&amp;</c-> <c- n>overlap_flag</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="11"></span><span class="line">          <c- n>old</c-> <c- o>=</c-> <c- n>noiseStripe</c-><c- p>[</c-> <c- n>lumaNum</c-> <c- o>-</c-> <c- mi>1</c-> <c- p>][</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>i</c-> <c- o>+</c-> <c- n>lumaSize</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-></span><span class="line-no" data-line="12"></span><span class="line">          <c- k>if</c-> <c- p>(</c-> <c- n>i</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="13"></span><span class="line">            <c- n>g</c-> <c- o>=</c-> <c- n>old</c-> <c- o>*</c-> <c- mi>27</c-> <c- o>+</c-> <c- n>g</c-> <c- o>*</c-> <c- mi>17</c-></span><span class="line-no" data-line="14"></span><span class="line">          <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="15"></span><span class="line">            <c- n>g</c-> <c- o>=</c-> <c- n>old</c-> <c- o>*</c-> <c- mi>17</c-> <c- o>+</c-> <c- n>g</c-> <c- o>*</c-> <c- mi>27</c-></span><span class="line-no" data-line="16"></span><span class="line">          <c- p>}</c-></span><span class="line-no" data-line="17"></span><span class="line">          <c- n>g</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- n>GrainMin</c-><c- p>,</c-> <c- n>GrainMax</c-><c- p>,</c-> <c- n>Round2</c-><c- p>(</c-><c- n>g</c-><c- p>,</c-> <c- mi>5</c-><c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="18"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="19"></span><span class="line">      <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="20"></span><span class="line">        <c- k>if</c-> <c- p>(</c-> <c- n>i</c-> <c- o>&lt;</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>lumaNum</c-> <c- o>></c-> <c- mi>0</c-> <c- o>&amp;&amp;</c-> <c- n>overlap_flag</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="21"></span><span class="line">          <c- n>old</c-> <c- o>=</c-> <c- n>noiseStripe</c-><c- p>[</c-> <c- n>lumaNum</c-> <c- o>-</c-> <c- mi>1</c-> <c- p>][</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>i</c-> <c- o>+</c-> <c- p>(</c-><c- n>lumaSize</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-></span><span class="line-no" data-line="22"></span><span class="line">          <c- n>g</c-> <c- o>=</c-> <c- n>old</c-> <c- o>*</c-> <c- mi>23</c-> <c- o>+</c-> <c- n>g</c-> <c- o>*</c-> <c- mi>22</c-></span><span class="line-no" data-line="23"></span><span class="line">          <c- n>g</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- n>GrainMin</c-><c- p>,</c-> <c- n>GrainMax</c-><c- p>,</c-> <c- n>Round2</c-><c- p>(</c-><c- n>g</c-><c- p>,</c-> <c- mi>5</c-><c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="24"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="25"></span><span class="line">      <c- p>}</c-></span><span class="line-no" data-line="26"></span><span class="line">      <c- n>noiseImage</c-><c- p>[</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>g</c-></span><span class="line-no" data-line="27"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="28"></span><span class="line">  <c- p>}</c-></span><span class="line-no" data-line="29"></span><span class="line"><c- p>}</c-></span></pre>
   <p class="note" role="note"><span class="marker">Note:</span> Although this process is specified in terms of full size noiseStripe and noiseImage arrays,
the reference code shows how it is possible to implement the grain synthesis with just 2 line buffers for luma,
and 1 line buffer for each chroma <a data-link-type="dfn" href="#component" id="ref-for-component①①">component</a>.</p>
   <p>Finally, the noise is blended with the original image data as follows:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- k>if</c-> <c- p>(</c-> <c- n>clip_to_restricted_range</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">  <c- n>minValue</c-> <c- o>=</c-> <c- mi>16</c-> <c- o>&lt;&lt;</c-> <c- p>(</c-><c- n>bitDepth</c-> <c- o>-</c-> <c- mi>8</c-><c- p>)</c-></span><span class="line-no" data-line="3"></span><span class="line">  <c- n>maxLuma</c-> <c- o>=</c-> <c- mi>235</c-> <c- o>&lt;&lt;</c-> <c- p>(</c-><c- n>bitDepth</c-> <c- o>-</c-> <c- mi>8</c-><c- p>)</c-></span><span class="line-no" data-line="4"></span><span class="line">  <c- k>if</c-> <c- p>(</c-> <c- n>mcIdentity</c-> <c- p>)</c-></span><span class="line-no" data-line="5"></span><span class="line">    <c- n>maxChroma</c-> <c- o>=</c-> <c- n>maxLuma</c-></span><span class="line-no" data-line="6"></span><span class="line">  <c- k>else</c-></span><span class="line-no" data-line="7"></span><span class="line">    <c- n>maxChroma</c-> <c- o>=</c-> <c- mi>240</c-> <c- o>&lt;&lt;</c-> <c- p>(</c-><c- n>bitDepth</c-> <c- o>-</c-> <c- mi>8</c-><c- p>)</c-></span><span class="line-no" data-line="8"></span><span class="line"><c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="9"></span><span class="line">  <c- n>minValue</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="10"></span><span class="line">  <c- n>maxLuma</c-> <c- o>=</c-> <c- p>(</c-><c- mi>256</c-> <c- o>&lt;&lt;</c-> <c- p>(</c-><c- n>bitDepth</c-> <c- o>-</c-> <c- mi>8</c-><c- p>))</c-> <c- o>-</c-> <c- mi>1</c-></span><span class="line-no" data-line="11"></span><span class="line">  <c- n>maxChroma</c-> <c- o>=</c-> <c- n>maxLuma</c-></span><span class="line-no" data-line="12"></span><span class="line"><c- p>}</c-></span><span class="line-no" data-line="13"></span><span class="line"><c- n>ScalingShift</c-> <c- o>=</c-> <c- n>grain_scaling_minus_8</c-> <c- o>+</c-> <c- mi>8</c-></span><span class="line-no" data-line="14"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>y</c-> <c- o>&lt;</c-> <c- p>(</c-> <c- p>(</c-><c- n>h</c-> <c- o>+</c-> <c- n>subY</c-><c- p>)</c-> <c- o>>></c-> <c- n>subY</c-><c- p>)</c-> <c- p>;</c-> <c- n>y</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="15"></span><span class="line">  <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- p>(</c-> <c- p>(</c-><c- n>w</c-> <c- o>+</c-> <c- n>subX</c-><c- p>)</c-> <c- o>>></c-> <c- n>subX</c-><c- p>)</c-> <c- p>;</c-> <c- n>x</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="16"></span><span class="line">    <c- n>lumaX</c-> <c- o>=</c-> <c- n>x</c-> <c- o>&lt;&lt;</c-> <c- n>subX</c-></span><span class="line-no" data-line="17"></span><span class="line">    <c- n>lumaY</c-> <c- o>=</c-> <c- n>y</c-> <c- o>&lt;&lt;</c-> <c- n>subY</c-></span><span class="line-no" data-line="18"></span><span class="line">    <c- n>lumaNextX</c-> <c- o>=</c-> <c- n>Min</c-><c- p>(</c-> <c- n>lumaX</c-> <c- o>+</c-> <c- mi>1</c-><c- p>,</c-> <c- n>w</c-> <c- o>-</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="19"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>subX</c-> <c- p>)</c-></span><span class="line-no" data-line="20"></span><span class="line">      <c- n>averageLuma</c-> <c- o>=</c-></span><span class="line-no" data-line="21"></span><span class="line">          <c- n>Round2</c-><c- p>(</c-> <c- n>OutY</c-><c- p>[</c-> <c- n>lumaY</c-> <c- p>][</c-> <c- n>lumaX</c-> <c- p>]</c-> <c- o>+</c-> <c- n>OutY</c-><c- p>[</c-> <c- n>lumaY</c-> <c- p>][</c-> <c- n>lumaNextX</c-> <c- p>],</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="22"></span><span class="line">    <c- k>else</c-></span><span class="line-no" data-line="23"></span><span class="line">      <c- n>averageLuma</c-> <c- o>=</c-> <c- n>OutY</c-><c- p>[</c-> <c- n>lumaY</c-> <c- p>][</c-> <c- n>lumaX</c-> <c- p>]</c-></span><span class="line-no" data-line="24"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>num_cb_points</c-> <c- o>></c-> <c- mi>0</c-> <c- o>||</c-> <c- n>chroma_scaling_from_luma</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="25"></span><span class="line">      <c- n>orig</c-> <c- o>=</c-> <c- n>OutU</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-></span><span class="line-no" data-line="26"></span><span class="line">      <c- k>if</c-> <c- p>(</c-> <c- n>chroma_scaling_from_luma</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="27"></span><span class="line">        <c- n>merged</c-> <c- o>=</c-> <c- n>averageLuma</c-></span><span class="line-no" data-line="28"></span><span class="line">      <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="29"></span><span class="line">        <c- n>combined</c-> <c- o>=</c-> <c- n>averageLuma</c-> <c- o>*</c-> <c- p>(</c-> <c- n>cb_luma_mult</c-> <c- o>-</c-> <c- mi>128</c-> <c- p>)</c-> <c- o>+</c-></span><span class="line-no" data-line="30"></span><span class="line">                   <c- n>orig</c-> <c- o>*</c-> <c- p>(</c-> <c- n>cb_mult</c-> <c- o>-</c-> <c- mi>128</c-> <c- p>)</c-></span><span class="line-no" data-line="31"></span><span class="line">        <c- n>merged</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- mi>0</c-><c- p>,</c-> <c- p>(</c-><c- mi>1</c-> <c- o>&lt;&lt;</c-> <c- n>bitDepth</c-><c- p>)</c-> <c- o>-</c-> <c- mi>1</c-><c- p>,</c-> </span><span class="line-no" data-line="32"></span><span class="line">                        <c- p>(</c-> <c- n>combined</c-> <c- o>>></c-> <c- mi>6</c-> <c- p>)</c-> <c- o>+</c-></span><span class="line-no" data-line="33"></span><span class="line">                        <c- p>(</c-> <c- p>(</c-><c- n>cb_offset</c-> <c- o>-</c-> <c- mi>256</c-> <c- p>)</c-> <c- o>&lt;&lt;</c-> <c- p>(</c-><c- n>bitDepth</c-> <c- o>-</c-> <c- mi>8</c-><c- p>)</c-> <c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="34"></span><span class="line">      <c- p>}</c-></span><span class="line-no" data-line="35"></span><span class="line">      <c- n>noise</c-> <c- o>=</c-> <c- n>noiseImage</c-><c- p>[</c-> <c- mi>1</c-> <c- p>][</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-></span><span class="line-no" data-line="36"></span><span class="line">      <c- n>noise</c-> <c- o>=</c-> <c- n>Round2</c-><c- p>(</c-> <c- n>scale_lut</c-><c- p>(</c-> <c- mi>1</c-><c- p>,</c-> <c- n>merged</c-><c- p>,</c-> <c- n>bitDepth</c-> <c- p>)</c-> <c- o>*</c-> <c- n>noise</c-><c- p>,</c-> <c- n>ScalingShift</c-> <c- p>)</c-></span><span class="line-no" data-line="37"></span><span class="line">      <c- n>OutU</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- n>minValue</c-><c- p>,</c-> <c- n>maxChroma</c-><c- p>,</c-> <c- n>orig</c-> <c- o>+</c-> <c- n>noise</c-> <c- p>)</c-></span><span class="line-no" data-line="38"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="39"></span><span class="line"></span><span class="line-no" data-line="40"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>num_cr_points</c-> <c- o>></c-> <c- mi>0</c-> <c- o>||</c-> <c- n>chroma_scaling_from_luma</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="41"></span><span class="line">      <c- n>orig</c-> <c- o>=</c-> <c- n>OutV</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-></span><span class="line-no" data-line="42"></span><span class="line">      <c- k>if</c-> <c- p>(</c-> <c- n>chroma_scaling_from_luma</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="43"></span><span class="line">        <c- n>merged</c-> <c- o>=</c-> <c- n>averageLuma</c-></span><span class="line-no" data-line="44"></span><span class="line">      <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="45"></span><span class="line">        <c- n>combined</c-> <c- o>=</c-> <c- n>averageLuma</c-> <c- o>*</c-> <c- p>(</c-> <c- n>cr_luma_mult</c-> <c- o>-</c-> <c- mi>128</c-> <c- p>)</c-> <c- o>+</c-></span><span class="line-no" data-line="46"></span><span class="line">                   <c- n>orig</c-> <c- o>*</c-> <c- p>(</c-> <c- n>cr_mult</c-> <c- o>-</c-> <c- mi>128</c-> <c- p>)</c-></span><span class="line-no" data-line="47"></span><span class="line">        <c- n>merged</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- mi>0</c-><c- p>,</c-> <c- p>(</c-><c- mi>1</c-> <c- o>&lt;&lt;</c-> <c- n>bitDepth</c-><c- p>)</c-> <c- o>-</c-> <c- mi>1</c-><c- p>,</c-> <c- p>(</c-> <c- n>combined</c-> <c- o>>></c-> <c- mi>6</c-> <c- p>)</c-> <c- o>+</c-></span><span class="line-no" data-line="48"></span><span class="line">                        <c- p>(</c-> <c- p>(</c-><c- n>cr_offset</c-> <c- o>-</c-> <c- mi>256</c-> <c- p>)</c-> <c- o>&lt;&lt;</c-> <c- p>(</c-><c- n>bitDepth</c-> <c- o>-</c-> <c- mi>8</c-><c- p>)</c-> <c- p>)</c-> <c- p>)</c-></span><span class="line-no" data-line="49"></span><span class="line">      <c- p>}</c-></span><span class="line-no" data-line="50"></span><span class="line">      <c- n>noise</c-> <c- o>=</c-> <c- n>noiseImage</c-><c- p>[</c-> <c- mi>2</c-> <c- p>][</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-></span><span class="line-no" data-line="51"></span><span class="line">      <c- n>noise</c-> <c- o>=</c-> <c- n>Round2</c-><c- p>(</c-> <c- n>scale_lut</c-><c- p>(</c-> <c- mi>2</c-><c- p>,</c-> <c- n>merged</c-><c- p>,</c-> <c- n>bitDepth</c-> <c- p>)</c-> <c- o>*</c-> <c- n>noise</c-><c- p>,</c-> <c- n>ScalingShift</c-> <c- p>)</c-></span><span class="line-no" data-line="52"></span><span class="line">      <c- n>OutV</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- n>minValue</c-><c- p>,</c-> <c- n>maxChroma</c-><c- p>,</c-> <c- n>orig</c-> <c- o>+</c-> <c- n>noise</c-> <c- p>)</c-></span><span class="line-no" data-line="53"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="54"></span><span class="line">  <c- p>}</c-></span><span class="line-no" data-line="55"></span><span class="line"><c- p>}</c-></span><span class="line-no" data-line="56"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>y</c-> <c- o>&lt;</c-> <c- n>h</c-> <c- p>;</c-> <c- n>y</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="57"></span><span class="line">  <c- k>for</c-> <c- p>(</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>x</c-> <c- o>&lt;</c-> <c- n>w</c-> <c- p>;</c-> <c- n>x</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="58"></span><span class="line">    <c- n>orig</c-> <c- o>=</c-> <c- n>OutY</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-></span><span class="line-no" data-line="59"></span><span class="line">    <c- n>noise</c-> <c- o>=</c-> <c- n>noiseImage</c-><c- p>[</c-> <c- mi>0</c-> <c- p>][</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-></span><span class="line-no" data-line="60"></span><span class="line">    <c- n>noise</c-> <c- o>=</c-> <c- n>Round2</c-><c- p>(</c-> <c- n>scale_lut</c-><c- p>(</c-> <c- mi>0</c-><c- p>,</c-> <c- n>orig</c-><c- p>,</c-> <c- n>bitDepth</c-> <c- p>)</c-> <c- o>*</c-> <c- n>noise</c-><c- p>,</c-> <c- n>ScalingShift</c-> <c- p>)</c-></span><span class="line-no" data-line="61"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>num_y_points</c-> <c- o>></c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="62"></span><span class="line">      <c- n>OutY</c-><c- p>[</c-> <c- n>y</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- n>minValue</c-><c- p>,</c-> <c- n>maxLuma</c-><c- p>,</c-> <c- n>orig</c-> <c- o>+</c-> <c- n>noise</c-> <c- p>)</c-></span><span class="line-no" data-line="63"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="64"></span><span class="line">  <c- p>}</c-></span><span class="line-no" data-line="65"></span><span class="line"><c- p>}</c-></span></pre>
   <p>where <code>scale_lut</code> is a function that performs a piecewise linear interpolation into the appropriate scaling table.
The <code>scale_lut</code> function is specified as follows:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>scale_lut</c-><c- p>(</c-> <c- n>plane</c-><c- p>,</c-> <c- n>index</c-><c- p>,</c-> <c- n>bitDepth</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">  <c- n>shift</c-> <c- o>=</c-> <c- n>bitDepth</c-> <c- o>-</c-> <c- mi>8</c-></span><span class="line-no" data-line="3"></span><span class="line">  <c- n>x</c-> <c- o>=</c-> <c- n>index</c-> <c- o>>></c-> <c- n>shift</c-></span><span class="line-no" data-line="4"></span><span class="line">  <c- n>rem</c-> <c- o>=</c-> <c- n>index</c-> <c- o>-</c-> <c- p>(</c-> <c- n>x</c-> <c- o>&lt;&lt;</c-> <c- n>shift</c-> <c- p>)</c-></span><span class="line-no" data-line="5"></span><span class="line">  <c- k>if</c-> <c- p>(</c-> <c- n>x</c-> <c- o>==</c-> <c- mi>255</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="6"></span><span class="line">    <c- k>return</c-> <c- n>ScalingLut</c-><c- p>[</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-></span><span class="line-no" data-line="7"></span><span class="line">  <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="8"></span><span class="line">    <c- n>start</c-> <c- o>=</c-> <c- n>ScalingLut</c-><c- p>[</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>x</c-> <c- p>]</c-></span><span class="line-no" data-line="9"></span><span class="line">    <c- n>end</c-> <c- o>=</c-> <c- n>ScalingLut</c-><c- p>[</c-> <c- n>plane</c-> <c- p>][</c-> <c- n>x</c-> <c- o>+</c-> <c- mi>1</c-> <c- p>]</c-></span><span class="line-no" data-line="10"></span><span class="line">    <c- k>return</c-> <c- n>start</c-> <c- o>+</c-> <c- n>Round2</c-><c- p>(</c-> <c- p>(</c-><c- n>end</c-> <c- o>-</c-> <c- n>start</c-><c- p>)</c-> <c- o>*</c-> <c- n>rem</c-><c- p>,</c-> <c- n>shift</c-> <c- p>)</c-></span><span class="line-no" data-line="11"></span><span class="line">  <c- p>}</c-></span><span class="line-no" data-line="12"></span><span class="line"><c- p>}</c-></span></pre>
   <h3 class="heading settled" data-level="7.21" id="motion_field_motion_vector_storage_process"><span class="secno">7.21. </span><span class="content">Motion field motion vector storage process</span><a class="self-link" href="#motion_field_motion_vector_storage_process"></a></h3>
   <p>The inputs to this process are:</p>
   <ul>
    <li data-md>
     <p>variables r and c specifying the location of the block in units of 4x4 blocks in the luma plane,</p>
    <li data-md>
     <p>a variable bSize specifying the size of the block,</p>
    <li data-md>
     <p>a variable mvMethod that affects how the motion vector to be stored is computed.</p>
   </ul>
   <p>This process applies some filtering and reordering to the motion vectors to prepare them
for storage as part of the reference frame update process.</p>
   <p>If enable_ref_frame_mvs is equal to 0, this process immediately terminates.</p>
   <p>The variables bw4, bh4 (describing the size of the
block in units of 4x4 blocks in the luma plane), and n (specifying the size of the optical flow
blocks within the block) are computed as follows:</p>
<pre class="language-cpp highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>bw4</c-> <c- o>=</c-> <c- n>Num_4x4_Blocks_Wide</c-><c- p>[</c-> <c- n>bSize</c-> <c- p>]</c-></span><span class="line-no" data-line="2"></span><span class="line"><c- n>bh4</c-> <c- o>=</c-> <c- n>Num_4x4_Blocks_High</c-><c- p>[</c-> <c- n>bSize</c-> <c- p>]</c-></span><span class="line-no" data-line="3"></span><span class="line"><c- n>n</c-> <c- o>=</c-> <c- p>(</c-><c- n>bw4</c-> <c- o>&lt;=</c-> <c- mi>2</c-> <c- o>&amp;&amp;</c-> <c- n>bh4</c-> <c- o>&lt;=</c-> <c- mi>2</c-> <c- o>&amp;&amp;</c-> <c- n>tip_frame_mode</c-> <c- o>!=</c-> <c- n>TIP_FRAME_AS_OUTPUT</c-><c- p>)</c-> <c- o>?</c-> <c- mi>4</c-> <c- o>:</c-> <c- mi>8</c-></span><span class="line-no" data-line="4"></span><span class="line"><c- n>bw4</c-> <c- o>=</c-> <c- n>Min</c-><c- p>(</c-><c- n>MiCols</c-> <c- o>-</c-> <c- n>c</c-><c- p>,</c-> <c- n>bw4</c-><c- p>)</c-></span><span class="line-no" data-line="5"></span><span class="line"><c- n>bh4</c-> <c- o>=</c-> <c- n>Min</c-><c- p>(</c-><c- n>MiRows</c-> <c- o>-</c-> <c- n>r</c-><c- p>,</c-> <c- n>bh4</c-><c- p>)</c-></span></pre>
   <p>The variables isWedge (specifying if the block uses a wedge compound mode of two
inter frames), refIdx0, refIdx1, and tipPred are computed as follows:</p>
<pre class="language-cpp highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>refIdx0</c-> <c- o>=</c-> <c- n>RefFrames</c-><c- p>[</c-> <c- n>r</c-> <c- p>][</c-> <c- n>c</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>]</c-></span><span class="line-no" data-line="2"></span><span class="line"><c- n>refIdx1</c-> <c- o>=</c-> <c- n>RefFrames</c-><c- p>[</c-> <c- n>r</c-> <c- p>][</c-> <c- n>c</c-> <c- p>][</c-> <c- mi>1</c-> <c- p>]</c-></span><span class="line-no" data-line="3"></span><span class="line"><c- n>isWedge</c-> <c- o>=</c-> <c- n>is_inter_ref_frame</c-><c- p>(</c-><c- n>refIdx0</c-><c- p>)</c-> <c- o>&amp;&amp;</c-> <c- n>is_inter_ref_frame</c-><c- p>(</c-><c- n>refIdx1</c-><c- p>)</c-> <c- o>&amp;&amp;</c-></span><span class="line-no" data-line="4"></span><span class="line">          <c- n>refIdx0</c-> <c- o>!=</c-> <c- n>TIP_FRAME</c-> <c- o>&amp;&amp;</c-> <c- n>compound_type</c-> <c- o>==</c-> <c- n>COMPOUND_WEDGE</c->  </span><span class="line-no" data-line="5"></span><span class="line"><c- n>tipPred</c-> <c- o>=</c-> <c- n>refIdx0</c-> <c- o>==</c-> <c- n>TIP_FRAME</c-></span><span class="line-no" data-line="6"></span><span class="line"><c- k>if</c-> <c- p>(</c-><c- n>tipPred</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="7"></span><span class="line">    <c- n>refIdx0</c-> <c- o>=</c-> <c- n>ClosestPast</c-></span><span class="line-no" data-line="8"></span><span class="line">    <c- n>refIdx1</c-> <c- o>=</c-> <c- n>ClosestFuture</c-></span><span class="line-no" data-line="9"></span><span class="line"><c- p>}</c->        </span><span class="line-no" data-line="10"></span><span class="line"><c- k>if</c-> <c- p>(</c-> <c- p>(</c-><c- n>tipPred</c-> <c- o>||</c-> <c- n>tip_frame_mode</c-> <c- o>==</c-> <c- n>TIP_FRAME_AS_OUTPUT</c-><c- p>)</c-> <c- o>&amp;&amp;</c-> </span><span class="line-no" data-line="11"></span><span class="line">     <c- n>Tip_Weighting_Factor</c-><c- p>[</c-> <c- n>tip_global_wtd_index</c-> <c- p>]</c-> <c- o>==</c-> <c- mi>16</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="12"></span><span class="line">    <c- n>refIdx1</c-> <c- o>=</c-> <c- n>NONE</c-></span><span class="line-no" data-line="13"></span><span class="line"><c- p>}</c-></span></pre>
   <p>The following applies for i8 = 0..Round2(bh4,1)-1, for j8 = 0..Round2(bw4,1)-1:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>allowList</c-><c- p>[</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- mi>1</c-></span><span class="line-no" data-line="2"></span><span class="line"><c- n>allowList</c-><c- p>[</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- mi>1</c-></span><span class="line-no" data-line="3"></span><span class="line"><c- k>if</c-> <c- p>(</c-><c- n>isWedge</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="4"></span><span class="line">    <c- n>count0</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="5"></span><span class="line">    <c- n>count1</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="6"></span><span class="line">    <c- k>for</c-> <c- p>(</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>&lt;</c-> <c- mi>8</c-><c- p>;</c-> <c- n>i</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="7"></span><span class="line">        <c- k>for</c-><c- p>(</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>j</c-> <c- o>&lt;</c-> <c- mi>8</c-><c- p>;</c-> <c- n>j</c-><c- o>++</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="8"></span><span class="line">            <c- n>m</c-> <c- o>=</c-> <c- n>Mask</c-><c- p>[</c-> <c- n>i8</c-> <c- o>*</c-> <c- mi>8</c-> <c- o>+</c-> <c- n>i</c-> <c- p>][</c-> <c- n>j8</c-> <c- o>*</c-> <c- mi>8</c-> <c- o>+</c-> <c- n>j</c-> <c- p>]</c-></span><span class="line-no" data-line="9"></span><span class="line">            <c- k>if</c-> <c- p>(</c-> <c- n>m</c-> <c- o>></c-> <c- mi>60</c-> <c- p>)</c-></span><span class="line-no" data-line="10"></span><span class="line">                <c- n>count0</c-><c- o>++</c-></span><span class="line-no" data-line="11"></span><span class="line">            <c- k>if</c-> <c- p>(</c-> <c- n>m</c-> <c- o>&lt;</c-> <c- mi>4</c-> <c- p>)</c-></span><span class="line-no" data-line="12"></span><span class="line">                <c- n>count1</c-><c- o>++</c-></span><span class="line-no" data-line="13"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="14"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="15"></span><span class="line">    <c- k>if</c-> <c- p>(</c-><c- n>count0</c-> <c- o>>=</c-> <c- mi>60</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="16"></span><span class="line">        <c- n>allowList</c-><c- p>[</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="17"></span><span class="line">    <c- p>}</c-> <c- k>else</c-> <c- k>if</c-> <c- p>(</c-><c- n>count1</c-> <c- o>>=</c-> <c- mi>60</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="18"></span><span class="line">        <c- n>allowList</c-><c- p>[</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="19"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="20"></span><span class="line"><c- p>}</c-></span><span class="line-no" data-line="21"></span><span class="line"></span><span class="line-no" data-line="22"></span><span class="line"><c- n>x8</c-> <c- o>=</c-> <c- p>(</c-><c- n>c</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- o>+</c-> <c- n>j8</c-></span><span class="line-no" data-line="23"></span><span class="line"><c- n>y8</c-> <c- o>=</c-> <c- p>(</c-><c- n>r</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- o>+</c-> <c- n>i8</c-></span><span class="line-no" data-line="24"></span><span class="line"><c- n>row</c-> <c- o>=</c-> <c- n>r</c-> <c- o>+</c-> <c- p>(</c-><c- n>i8</c-> <c- o>&lt;&lt;</c-> <c- mi>1</c-><c- p>)</c-></span><span class="line-no" data-line="25"></span><span class="line"><c- n>col</c-> <c- o>=</c-> <c- n>c</c-> <c- o>+</c-> <c- p>(</c-><c- n>j8</c-> <c- o>&lt;&lt;</c-> <c- mi>1</c-><c- p>)</c-></span><span class="line-no" data-line="26"></span><span class="line"><c- k>for</c-><c- p>(</c-> <c- n>list</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-><c- n>list</c-> <c- o>&lt;</c-> <c- mi>2</c-><c- p>;</c-> <c- n>list</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="27"></span><span class="line">    <c- n>refs</c-><c- p>[</c-> <c- n>list</c-> <c- p>]</c-> <c- o>=</c-> <c- n>NONE</c-></span><span class="line-no" data-line="28"></span><span class="line">    <c- k>for</c-><c- p>(</c-> <c- n>comp</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>comp</c-> <c- o>&lt;</c-> <c- mi>2</c-><c- p>;</c-> <c- n>comp</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="29"></span><span class="line">        <c- n>mfmvs</c-><c- p>[</c-> <c- n>list</c-> <c- p>][</c-> <c- n>comp</c-> <c- p>]</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="30"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="31"></span><span class="line"><c- p>}</c-></span><span class="line-no" data-line="32"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>list</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>list</c-> <c- o>&lt;</c-> <c- mi>2</c-><c- p>;</c-> <c- n>list</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="33"></span><span class="line">    <c- n>refIdx</c-> <c- o>=</c-> <c- n>list</c-> <c- o>==</c-> <c- mi>0</c-> <c- o>?</c-> <c- n>refIdx0</c-> <c- o>:</c-> <c- n>refIdx1</c-></span><span class="line-no" data-line="34"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>is_inter_ref_frame</c-><c- p>(</c-><c- n>refIdx</c-><c- p>)</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="35"></span><span class="line">        <c- k>if</c-> <c- p>(</c-> <c- n>mvMethod</c-> <c- o>></c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="36"></span><span class="line">            <c- n>mvs</c-> <c- o>=</c-> <c- p>(</c-> <c- n>use_refinemv</c-> <c- o>||</c-> <c- n>tipPred</c-> <c- p>)</c-> <c- o>?</c-></span><span class="line-no" data-line="37"></span><span class="line">                      <c- n>RefineMvs</c-><c- p>[</c-> <c- n>i8</c-> <c- o>&lt;&lt;</c-> <c- mi>1</c-> <c- p>][</c-> <c- n>j8</c-> <c- o>&lt;&lt;</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>:</c-> <c- n>Mvs</c-><c- p>[</c-> <c- n>row</c-> <c- p>][</c-> <c- n>col</c-> <c- p>]</c-></span><span class="line-no" data-line="38"></span><span class="line">            <c- n>mvRow</c-> <c- o>=</c-> <c- n>mvs</c-><c- p>[</c-><c- n>list</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-></span><span class="line-no" data-line="39"></span><span class="line">            <c- n>mvCol</c-> <c- o>=</c-> <c- n>mvs</c-><c- p>[</c-><c- n>list</c-><c- p>][</c-><c- mi>1</c-><c- p>]</c-></span><span class="line-no" data-line="40"></span><span class="line">            <c- k>if</c-> <c- p>(</c-> <c- n>mvMethod</c-><c- o>==</c-><c- mi>1</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="41"></span><span class="line">                <c- k>if</c-> <c- p>(</c-> <c- n>n</c-><c- o>==</c-><c- mi>4</c-> <c- o>&amp;&amp;</c-> <c- o>!</c-><c- n>tipPred</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="42"></span><span class="line">                    <c- n>totalRow</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="43"></span><span class="line">                    <c- n>totalCol</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="44"></span><span class="line">                    <c- k>for</c-><c- p>(</c-><c- n>a</c-><c- o>=</c-><c- mi>0</c-><c- p>;</c-><c- n>a</c-><c- o>&lt;</c-><c- mi>2</c-><c- p>;</c-><c- n>a</c-><c- o>++</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="45"></span><span class="line">                        <c- k>for</c-><c- p>(</c-><c- n>b</c-><c- o>=</c-><c- mi>0</c-><c- p>;</c-><c- n>b</c-><c- o>&lt;</c-><c- mi>2</c-><c- p>;</c-><c- n>b</c-><c- o>++</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="46"></span><span class="line">                            <c- n>totalRow</c-> <c- o>+=</c-> <c- n>MvDeltas</c-><c- p>[</c-> <c- n>a</c-> <c- p>][</c-> <c- n>b</c-> <c- p>][</c-> <c- n>list</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>]</c-></span><span class="line-no" data-line="47"></span><span class="line">                            <c- n>totalCol</c-> <c- o>+=</c-> <c- n>MvDeltas</c-><c- p>[</c-> <c- n>a</c-> <c- p>][</c-> <c- n>b</c-> <c- p>][</c-> <c- n>list</c-> <c- p>][</c-> <c- mi>1</c-> <c- p>]</c-></span><span class="line-no" data-line="48"></span><span class="line">                        <c- p>}</c-></span><span class="line-no" data-line="49"></span><span class="line">                    <c- p>}</c-></span><span class="line-no" data-line="50"></span><span class="line">                    <c- n>mvRow</c-> <c- o>+=</c-> <c- n>Round2Signed</c-><c- p>(</c-><c- n>totalRow</c-><c- p>,</c-> <c- mi>1</c-> <c- o>+</c-> <c- mi>2</c-><c- p>)</c-></span><span class="line-no" data-line="51"></span><span class="line">                    <c- n>mvCol</c-> <c- o>+=</c-> <c- n>Round2Signed</c-><c- p>(</c-><c- n>totalCol</c-><c- p>,</c-> <c- mi>1</c-> <c- o>+</c-> <c- mi>2</c-><c- p>)</c-></span><span class="line-no" data-line="52"></span><span class="line">                <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="53"></span><span class="line">                    <c- n>mvRow</c-> <c- o>+=</c-> <c- n>Round2Signed</c-><c- p>(</c-></span><span class="line-no" data-line="54"></span><span class="line">                                 <c- n>MvDeltas</c-><c- p>[</c-> <c- n>i8</c-> <c- o>&lt;&lt;</c-> <c- mi>1</c-> <c- p>][</c-> <c- n>j8</c-> <c- o>&lt;&lt;</c-> <c- mi>1</c-> <c- p>][</c-> <c- n>list</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>],</c-> <c- mi>1</c-><c- p>)</c-></span><span class="line-no" data-line="55"></span><span class="line">                    <c- n>mvCol</c-> <c- o>+=</c-> <c- n>Round2Signed</c-><c- p>(</c-></span><span class="line-no" data-line="56"></span><span class="line">                                 <c- n>MvDeltas</c-><c- p>[</c-> <c- n>i8</c-> <c- o>&lt;&lt;</c-> <c- mi>1</c-> <c- p>][</c-> <c- n>j8</c-> <c- o>&lt;&lt;</c-> <c- mi>1</c-> <c- p>][</c-> <c- n>list</c-> <c- p>][</c-> <c- mi>1</c-> <c- p>],</c-> <c- mi>1</c-><c- p>)</c-></span><span class="line-no" data-line="57"></span><span class="line">                <c- p>}</c-></span><span class="line-no" data-line="58"></span><span class="line">            <c- p>}</c-></span><span class="line-no" data-line="59"></span><span class="line">        <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="60"></span><span class="line">            <c- k>if</c-> <c- p>(</c-> <c- n>tipPred</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="61"></span><span class="line">                <c- n>candMvs</c-> <c- o>=</c-> <c- n>get_tip_cand</c-><c- p>(</c-> <c- n>row</c-><c- p>,</c-> <c- n>col</c-> <c- p>)</c-></span><span class="line-no" data-line="62"></span><span class="line">                <c- n>mv</c-> <c- o>=</c-> <c- n>candMvs</c-><c- p>[</c-> <c- n>list</c-> <c- p>]</c-></span><span class="line-no" data-line="63"></span><span class="line">            <c- p>}</c-> <c- k>else</c-> <c- k>if</c-> <c- p>(</c-> <c- n>motion_mode</c-> <c- o>>=</c-> <c- n>LOCALWARP</c-> <c- o>&amp;&amp;</c-> <c- n>LocalValid</c-><c- p>[</c-> <c- n>list</c-> <c- p>]</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="64"></span><span class="line">                <c- n>mv</c-> <c- o>=</c-> <c- n>get_sub_block_warp_mv</c-><c- p>(</c-> <c- n>LocalWarpParams</c-><c- p>[</c-> <c- n>list</c-> <c- p>],</c-> <c- mi>0</c-><c- p>,</c-></span><span class="line-no" data-line="65"></span><span class="line">                                            <c- n>col</c-> <c- o>*</c-> <c- n>MI_SIZE</c-><c- p>,</c-> <c- n>row</c-> <c- o>*</c-> <c- n>MI_SIZE</c-><c- p>,</c-></span><span class="line-no" data-line="66"></span><span class="line">                                            <c- mi>8</c-><c- p>,</c-> <c- mi>8</c-><c- p>,</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="67"></span><span class="line">            <c- p>}</c-> <c- k>else</c-> <c- k>if</c-> <c- p>(</c-> <c- n>is_global_mv_cand</c-><c- p>(</c-> <c- n>YMode</c-><c- p>,</c-> <c- n>bSize</c-><c- p>,</c-> <c- n>refIdx</c-> <c- p>)</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="68"></span><span class="line">                <c- n>mv</c-> <c- o>=</c-> <c- n>get_sub_block_warp_mv</c-><c- p>(</c-> <c- n>gm_params</c-><c- p>[</c-> <c- n>refIdx</c-> <c- p>],</c-> <c- mi>0</c-><c- p>,</c-></span><span class="line-no" data-line="69"></span><span class="line">                                            <c- n>col</c-> <c- o>*</c-> <c- n>MI_SIZE</c-><c- p>,</c-> <c- n>row</c-> <c- o>*</c-> <c- n>MI_SIZE</c-><c- p>,</c-></span><span class="line-no" data-line="70"></span><span class="line">                                            <c- mi>8</c-><c- p>,</c-> <c- mi>8</c-><c- p>,</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="71"></span><span class="line">            <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="72"></span><span class="line">                <c- n>mv</c-> <c- o>=</c-> <c- n>Mvs</c-><c- p>[</c-> <c- n>row</c-> <c- p>][</c-> <c- n>col</c-> <c- p>][</c-> <c- n>list</c-> <c- p>]</c-></span><span class="line-no" data-line="73"></span><span class="line">            <c- p>}</c-></span><span class="line-no" data-line="74"></span><span class="line">            <c- n>mvRow</c-> <c- o>=</c-> <c- n>mv</c-><c- p>[</c-> <c- mi>0</c-> <c- p>]</c-></span><span class="line-no" data-line="75"></span><span class="line">            <c- n>mvCol</c-> <c- o>=</c-> <c- n>mv</c-><c- p>[</c-> <c- mi>1</c-> <c- p>]</c-></span><span class="line-no" data-line="76"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="77"></span><span class="line">        </span><span class="line-no" data-line="78"></span><span class="line">        <c- k>if</c-> <c- p>(</c-> <c- n>Abs</c-><c- p>(</c-> <c- n>mvRow</c-> <c- p>)</c-> <c- o>&lt;=</c-> <c- n>REFMVS_LIMIT</c-> <c- o>&amp;&amp;</c-> <c- n>Abs</c-><c- p>(</c-> <c- n>mvCol</c-> <c- p>)</c-> <c- o>&lt;=</c-> <c- n>REFMVS_LIMIT</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="79"></span><span class="line">            <c- k>if</c-> <c- p>(</c-> <c- n>allowList</c-><c- p>[</c-><c- n>list</c-><c- p>]</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="80"></span><span class="line">                <c- n>mfmvs</c-><c- p>[</c-> <c- n>list</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- n>mvRow</c-></span><span class="line-no" data-line="81"></span><span class="line">                <c- n>mfmvs</c-><c- p>[</c-> <c- n>list</c-> <c- p>][</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- n>mvCol</c-></span><span class="line-no" data-line="82"></span><span class="line">                <c- n>refs</c-><c- p>[</c-> <c- n>list</c-> <c- p>]</c-> <c- o>=</c-> <c- n>refIdx</c-></span><span class="line-no" data-line="83"></span><span class="line">            <c- p>}</c-></span><span class="line-no" data-line="84"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="85"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="86"></span><span class="line"><c- p>}</c-></span><span class="line-no" data-line="87"></span><span class="line"><c- n>ref0</c-> <c- o>=</c-> <c- n>refs</c-><c- p>[</c-> <c- mi>0</c-> <c- p>]</c-></span><span class="line-no" data-line="88"></span><span class="line"><c- n>mvRow0</c-> <c- o>=</c-> <c- n>mfmvs</c-><c- p>[</c-> <c- mi>0</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>]</c-></span><span class="line-no" data-line="89"></span><span class="line"><c- n>mvCol0</c-> <c- o>=</c-> <c- n>mfmvs</c-><c- p>[</c-> <c- mi>0</c-> <c- p>][</c-> <c- mi>1</c-> <c- p>]</c-></span><span class="line-no" data-line="90"></span><span class="line"><c- n>ref1</c-> <c- o>=</c-> <c- n>refs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>]</c-></span><span class="line-no" data-line="91"></span><span class="line"><c- n>mvRow1</c-> <c- o>=</c-> <c- n>mfmvs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>]</c-></span><span class="line-no" data-line="92"></span><span class="line"><c- n>mvCol1</c-> <c- o>=</c-> <c- n>mfmvs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>][</c-> <c- mi>1</c-> <c- p>]</c-></span><span class="line-no" data-line="93"></span><span class="line"><c- k>if</c-> <c- p>(</c-> <c- n>ref0</c-> <c- o>!=</c-> <c- n>NONE</c-> <c- o>&amp;&amp;</c-> <c- n>ref1</c-> <c- o>==</c-> <c- n>NONE</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="94"></span><span class="line">    <c- n>refs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- n>ref0</c-></span><span class="line-no" data-line="95"></span><span class="line">    <c- n>mfmvs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- n>mvRow0</c-></span><span class="line-no" data-line="96"></span><span class="line">    <c- n>mfmvs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>][</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- n>mvCol0</c-></span><span class="line-no" data-line="97"></span><span class="line"><c- p>}</c-> <c- k>else</c-> <c- k>if</c-> <c- p>(</c-> <c- n>ref1</c-> <c- o>!=</c-> <c- n>NONE</c-> <c- o>&amp;&amp;</c-> <c- n>ref0</c-> <c- o>==</c-> <c- n>NONE</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="98"></span><span class="line">    <c- n>refs</c-><c- p>[</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- n>ref1</c-></span><span class="line-no" data-line="99"></span><span class="line">    <c- n>mfmvs</c-><c- p>[</c-> <c- mi>0</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- n>mvRow1</c-></span><span class="line-no" data-line="100"></span><span class="line">    <c- n>mfmvs</c-><c- p>[</c-> <c- mi>0</c-> <c- p>][</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- n>mvCol1</c-></span><span class="line-no" data-line="101"></span><span class="line"><c- p>}</c-> <c- k>else</c-> <c- k>if</c-> <c- p>(</c-> <c- n>ref0</c-> <c- o>!=</c-> <c- n>NONE</c-> <c- o>&amp;&amp;</c-> <c- n>refs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>!=</c-> <c- n>NONE</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="102"></span><span class="line">    <c- n>refOrder0</c-> <c- o>=</c-> <c- n>OrderHints</c-><c- p>[</c-><c- n>ref0</c-><c- p>]</c-></span><span class="line-no" data-line="103"></span><span class="line">    <c- n>refOrder1</c-> <c- o>=</c-> <c- n>OrderHints</c-><c- p>[</c-><c- n>ref1</c-><c- p>]</c-></span><span class="line-no" data-line="104"></span><span class="line">    <c- k>if</c-> <c- p>(</c-><c- n>refOrder0</c-> <c- o>&lt;</c-> <c- n>OrderHint</c-> <c- o>&amp;&amp;</c-> <c- n>refOrder1</c-> <c- o>&lt;</c-> <c- n>OrderHint</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="105"></span><span class="line">        <c- n>toSwitch</c-> <c- o>=</c-> <c- n>refOrder0</c-> <c- o>&lt;</c-> <c- n>refOrder1</c-></span><span class="line-no" data-line="106"></span><span class="line">    <c- p>}</c-> <c- k>else</c-> <c- k>if</c-> <c- p>(</c-><c- n>refOrder0</c-> <c- o>></c-> <c- n>OrderHint</c-> <c- o>&amp;&amp;</c-> <c- n>refOrder1</c-> <c- o>></c-> <c- n>OrderHint</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="107"></span><span class="line">        <c- n>toSwitch</c-> <c- o>=</c-> <c- n>refOrder1</c-> <c- o>></c-> <c- n>refOrder0</c-></span><span class="line-no" data-line="108"></span><span class="line">    <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="109"></span><span class="line">        <c- n>toSwitch</c-> <c- o>=</c-> <c- n>refOrder0</c-> <c- o>></c-> <c- n>OrderHint</c-> <c- o>&amp;&amp;</c-> <c- n>refOrder1</c-> <c- o>&lt;</c-> <c- n>OrderHint</c-></span><span class="line-no" data-line="110"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="111"></span><span class="line">    <c- k>if</c-> <c- p>(</c-><c- n>toSwitch</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="112"></span><span class="line">        <c- n>refs</c-><c- p>[</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- n>ref1</c-></span><span class="line-no" data-line="113"></span><span class="line">        <c- n>mfmvs</c-><c- p>[</c-> <c- mi>0</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- n>mvRow1</c-></span><span class="line-no" data-line="114"></span><span class="line">        <c- n>mfmvs</c-><c- p>[</c-> <c- mi>0</c-> <c- p>][</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- n>mvCol1</c-></span><span class="line-no" data-line="115"></span><span class="line">        <c- n>refs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- n>ref0</c-></span><span class="line-no" data-line="116"></span><span class="line">        <c- n>mfmvs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- n>mvRow0</c-></span><span class="line-no" data-line="117"></span><span class="line">        <c- n>mfmvs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>][</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- n>mvCol0</c-></span><span class="line-no" data-line="118"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="119"></span><span class="line"><c- p>}</c-></span><span class="line-no" data-line="120"></span><span class="line"></span><span class="line-no" data-line="121"></span><span class="line"><c- k>for</c-> <c- p>(</c-> <c- n>list</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>list</c-> <c- o>&lt;</c-> <c- mi>2</c-><c- p>;</c-> <c- n>list</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="122"></span><span class="line">    <c- n>MfRefFrames</c-><c- p>[</c-> <c- n>y8</c-> <c- p>][</c-> <c- n>x8</c-> <c- p>][</c-> <c- n>list</c-> <c- p>]</c-> <c- o>=</c-> <c- n>refs</c-><c- p>[</c-> <c- n>list</c-> <c- p>]</c-></span><span class="line-no" data-line="123"></span><span class="line">    <c- k>for</c-> <c- p>(</c-> <c- n>comp</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>comp</c-> <c- o>&lt;</c-> <c- mi>2</c-><c- p>;</c-> <c- n>comp</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="124"></span><span class="line">        <c- n>MfMvs</c-><c- p>[</c-> <c- n>y8</c-> <c- p>][</c-> <c- n>x8</c-> <c- p>][</c-> <c- n>list</c-> <c- p>][</c-> <c- n>comp</c-> <c- p>]</c-> <c- o>=</c-> <c- n>compression_mv</c-><c- p>(</c-> <c- n>mfmvs</c-><c- p>[</c-><c- n>list</c-><c- p>][</c-><c- n>comp</c-><c- p>]</c-> <c- p>)</c-></span><span class="line-no" data-line="125"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="126"></span><span class="line"><c- p>}</c-></span></pre>
   <p>The functions get_tip_cand, get_tip_offsets, to_fullmv, get_sub_block_warp_mv are defined as:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>to_fullmv</c-><c- p>(</c-><c- n>mv</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- k>return</c-> <c- p>(</c-><c- n>mv</c-> <c- o>+</c-> <c- mi>3</c-> <c- o>+</c-> <c- p>((</c-><c- n>mv</c-> <c- o>>=</c-> <c- mi>0</c-><c- p>)</c-> <c- o>?</c-> <c- mi>1</c-> <c- o>:</c-> <c- mi>0</c-><c- p>)</c-> <c- p>)</c-> <c- o>>></c-> <c- mi>3</c-></span><span class="line-no" data-line="3"></span><span class="line"><c- p>}</c-></span><span class="line-no" data-line="4"></span><span class="line"></span><span class="line-no" data-line="5"></span><span class="line"><c- n>get_tip_cand</c-><c- p>(</c-><c- n>candRow</c-><c- p>,</c-><c- n>candCol</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="6"></span><span class="line">    <c- n>x8</c-> <c- o>=</c-> <c- n>candCol</c-> <c- o>>></c-> <c- mi>1</c-></span><span class="line-no" data-line="7"></span><span class="line">    <c- n>y8</c-> <c- o>=</c-> <c- n>candRow</c-> <c- o>>></c-> <c- mi>1</c-></span><span class="line-no" data-line="8"></span><span class="line">    <c- n>candMvs</c-><c- p>[</c-> <c- mi>0</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="9"></span><span class="line">    <c- n>candMvs</c-><c- p>[</c-> <c- mi>0</c-> <c- p>][</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="10"></span><span class="line">    <c- n>candMvs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="11"></span><span class="line">    <c- n>candMvs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>][</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="12"></span><span class="line">    <c- n>refX8</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- mi>0</c-><c- p>,</c-> <c- p>(</c-><c- n>MiCols</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- o>-</c-> <c- mi>1</c-><c- p>,</c-> <c- n>x8</c-> <c- p>)</c-></span><span class="line-no" data-line="13"></span><span class="line">    <c- n>refY8</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-> <c- mi>0</c-><c- p>,</c-> <c- p>(</c-><c- n>MiRows</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- o>-</c-> <c- mi>1</c-><c- p>,</c-> <c- n>y8</c-> <c- p>)</c-></span><span class="line-no" data-line="14"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>MotionFieldValid</c-><c- p>[</c-> <c- n>refY8</c-> <c- p>][</c-> <c- n>refX8</c-> <c- p>]</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="15"></span><span class="line">        <c- p>(</c-><c- n>refOffset</c-><c- p>,</c-> <c- n>pastOffset</c-><c- p>,</c-> <c- n>futureOffset</c-><c- p>)</c-> <c- o>=</c-> <c- n>get_tip_offsets</c-><c- p>()</c-></span><span class="line-no" data-line="16"></span><span class="line">        <c- n>candMvs</c-><c- p>[</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- n>get_mv_projection</c-><c- p>(</c-> <c- n>MotionFieldMvs</c-><c- p>[</c-> <c- n>refY8</c-> <c- p>][</c-> <c- n>refX8</c-> <c- p>],</c-> </span><span class="line-no" data-line="17"></span><span class="line">                                          <c- n>pastOffset</c-><c- p>,</c-> <c- n>refOffset</c-> <c- p>)</c-></span><span class="line-no" data-line="18"></span><span class="line">        <c- n>candMvs</c-><c- p>[</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- n>get_mv_projection</c-><c- p>(</c-> <c- n>MotionFieldMvs</c-><c- p>[</c-> <c- n>refY8</c-> <c- p>][</c-> <c- n>refX8</c-> <c- p>],</c-> </span><span class="line-no" data-line="19"></span><span class="line">                                          <c- n>futureOffset</c-><c- p>,</c-> <c- n>refOffset</c-> <c- p>)</c-></span><span class="line-no" data-line="20"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="21"></span><span class="line">    <c- k>for</c-><c- p>(</c-> <c- n>list</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>list</c-> <c- o>&lt;</c-> <c- mi>2</c-><c- p>;</c-> <c- n>list</c-><c- o>++</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="22"></span><span class="line">        <c- k>for</c-><c- p>(</c-><c- n>comp</c-><c- o>=</c-><c- mi>0</c-><c- p>;</c-><c- n>comp</c-><c- o>&lt;</c-><c- mi>2</c-><c- p>;</c-><c- n>comp</c-><c- o>++</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="23"></span><span class="line">            <c- n>candMvs</c-><c- p>[</c-> <c- n>list</c-> <c- p>][</c-> <c- n>comp</c-> <c- p>]</c-> <c- o>+=</c-> <c- n>Mvs</c-><c- p>[</c-> <c- n>candRow</c-> <c- p>][</c-> <c- n>candCol</c-> <c- p>][</c-> <c- mi>0</c-> <c- p>][</c-> <c- n>comp</c-> <c- p>]</c->   </span><span class="line-no" data-line="24"></span><span class="line">            <c- n>candMvs</c-><c- p>[</c-> <c- n>list</c-> <c- p>][</c-> <c- n>comp</c-> <c- p>]</c-> <c- o>=</c-> </span><span class="line-no" data-line="25"></span><span class="line">                <c- n>Clip3</c-><c- p>(</c-><c- n>MV_LOW</c-> <c- o>+</c-> <c- mi>1</c-><c- p>,</c-> <c- n>MV_UPP</c-> <c- o>-</c-> <c- mi>1</c-><c- p>,</c-> <c- n>candMvs</c-><c- p>[</c-> <c- n>list</c-> <c- p>][</c-> <c- n>comp</c-> <c- p>]</c-> <c- p>)</c-></span><span class="line-no" data-line="26"></span><span class="line">        <c- p>}</c-></span><span class="line-no" data-line="27"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="28"></span><span class="line">    <c- k>return</c-> <c- n>candMvs</c-></span><span class="line-no" data-line="29"></span><span class="line"><c- p>}</c-></span><span class="line-no" data-line="30"></span><span class="line"></span><span class="line-no" data-line="31"></span><span class="line"><c- n>get_tip_offsets</c-><c- p>()</c-> <c- p>{</c-></span><span class="line-no" data-line="32"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>NumFutureRefs</c-> <c- o>></c-> <c- mi>0</c-> <c- o>&amp;&amp;</c-> <c- n>NumPastRefs</c-> <c- o>></c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="33"></span><span class="line">        <c- n>refOffset</c-> <c- o>=</c-> <c- n>get_relative_dist</c-><c- p>(</c-> <c- n>OrderHints</c-><c- p>[</c-><c- n>ClosestFuture</c-><c- p>],</c-></span><span class="line-no" data-line="34"></span><span class="line">                                       <c- n>OrderHints</c-><c- p>[</c-><c- n>ClosestPast</c-><c- p>])</c-></span><span class="line-no" data-line="35"></span><span class="line">    <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="36"></span><span class="line">        <c- n>refOffset</c-> <c- o>=</c-> <c- n>get_relative_dist</c-><c- p>(</c-> <c- n>OrderHints</c-><c- p>[</c-><c- n>ClosestPast</c-><c- p>],</c-></span><span class="line-no" data-line="37"></span><span class="line">                                       <c- n>OrderHints</c-><c- p>[</c-><c- n>ClosestFuture</c-><c- p>])</c-></span><span class="line-no" data-line="38"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="39"></span><span class="line">    <c- n>pastOffset</c-> <c- o>=</c-> <c- n>get_relative_dist</c-><c- p>(</c-> <c- n>OrderHint</c-><c- p>,</c-></span><span class="line-no" data-line="40"></span><span class="line">                                    <c- n>OrderHints</c-><c- p>[</c-><c- n>ClosestPast</c-><c- p>])</c-></span><span class="line-no" data-line="41"></span><span class="line">    <c- n>futureOffset</c-> <c- o>=</c-> <c- n>get_relative_dist</c-><c- p>(</c-> <c- n>OrderHint</c-><c- p>,</c-></span><span class="line-no" data-line="42"></span><span class="line">                                      <c- n>OrderHints</c-><c- p>[</c-><c- n>ClosestFuture</c-><c- p>])</c-></span><span class="line-no" data-line="43"></span><span class="line">    <c- n>refOffset</c-> <c- o>=</c-> <c- n>Min</c-><c- p>(</c-> <c- n>refOffset</c-><c- p>,</c-> <c- n>MAX_FRAME_DISTANCE</c-> <c- p>)</c-></span><span class="line-no" data-line="44"></span><span class="line">    <c- k>return</c-> <c- p>(</c-><c- n>refOffset</c-><c- p>,</c-> <c- n>pastOffset</c-><c- p>,</c-> <c- n>futureOffset</c-><c- p>)</c-></span><span class="line-no" data-line="45"></span><span class="line"><c- p>}</c-></span><span class="line-no" data-line="46"></span><span class="line"></span><span class="line-no" data-line="47"></span><span class="line"><c- n>get_sub_block_warp_mv</c-><c- p>(</c-> <c- n>warpParams</c-><c- p>,</c-> <c- n>plane</c-><c- p>,</c-> <c- n>x</c-><c- p>,</c-> <c- n>y</c-><c- p>,</c-> <c- n>w</c-><c- p>,</c-> <c- n>h</c-><c- p>,</c-> <c- n>rnd</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="48"></span><span class="line">    <c- k>if</c-> <c- p>(</c-> <c- n>plane</c-> <c- o>==</c-> <c- mi>0</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="49"></span><span class="line">        <c- n>subX</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="50"></span><span class="line">        <c- n>subY</c-> <c- o>=</c-> <c- mi>0</c-></span><span class="line-no" data-line="51"></span><span class="line">    <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="52"></span><span class="line">        <c- n>subX</c-> <c- o>=</c-> <c- n>SubsamplingX</c-></span><span class="line-no" data-line="53"></span><span class="line">        <c- n>subY</c-> <c- o>=</c-> <c- n>SubsamplingY</c-></span><span class="line-no" data-line="54"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="55"></span><span class="line">    <c- n>srcX</c-> <c- o>=</c-> <c- p>(</c-><c- n>x</c-> <c- o>+</c-> <c- p>(</c-><c- n>w</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>)</c-> <c- o>&lt;&lt;</c-> <c- n>subX</c-></span><span class="line-no" data-line="56"></span><span class="line">    <c- n>srcY</c-> <c- o>=</c-> <c- p>(</c-><c- n>y</c-> <c- o>+</c-> <c- p>(</c-><c- n>h</c-> <c- o>>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>)</c-> <c- o>&lt;&lt;</c-> <c- n>subY</c-></span><span class="line-no" data-line="57"></span><span class="line">    <c- n>dstX</c-> <c- o>=</c-> <c- n>warpParams</c-><c- p>[</c-> <c- mi>2</c-> <c- p>]</c-> <c- o>*</c-> <c- n>srcX</c-> <c- o>+</c-> <c- n>warpParams</c-><c- p>[</c-> <c- mi>3</c-> <c- p>]</c-> <c- o>*</c-> <c- n>srcY</c-> <c- o>+</c-> <c- n>warpParams</c-><c- p>[</c-> <c- mi>0</c-> <c- p>]</c-></span><span class="line-no" data-line="58"></span><span class="line">    <c- n>dstY</c-> <c- o>=</c-> <c- n>warpParams</c-><c- p>[</c-> <c- mi>4</c-> <c- p>]</c-> <c- o>*</c-> <c- n>srcX</c-> <c- o>+</c-> <c- n>warpParams</c-><c- p>[</c-> <c- mi>5</c-> <c- p>]</c-> <c- o>*</c-> <c- n>srcY</c-> <c- o>+</c-> <c- n>warpParams</c-><c- p>[</c-> <c- mi>1</c-> <c- p>]</c-></span><span class="line-no" data-line="59"></span><span class="line">    <c- k>if</c-> <c- p>(</c-><c- n>rnd</c-><c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="60"></span><span class="line">        <c- n>mv</c-><c- p>[</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Round2Signed</c-><c- p>(</c-> <c- n>dstY</c-> <c- o>-</c-> <c- p>(</c-><c- n>srcY</c-> <c- o>&lt;&lt;</c-> <c- n>WARPEDMODEL_PREC_BITS</c-><c- p>),</c-> </span><span class="line-no" data-line="61"></span><span class="line">                                <c- n>WARPEDMODEL_PREC_BITS</c-> <c- o>-</c-> <c- mi>3</c-><c- p>)</c-></span><span class="line-no" data-line="62"></span><span class="line">        <c- n>mv</c-><c- p>[</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Round2Signed</c-><c- p>(</c-> <c- n>dstX</c-> <c- o>-</c-> <c- p>(</c-><c- n>srcX</c-> <c- o>&lt;&lt;</c-> <c- n>WARPEDMODEL_PREC_BITS</c-><c- p>),</c-> </span><span class="line-no" data-line="63"></span><span class="line">                                <c- n>WARPEDMODEL_PREC_BITS</c-> <c- o>-</c-> <c- mi>3</c-><c- p>)</c-></span><span class="line-no" data-line="64"></span><span class="line">    <c- p>}</c-> <c- k>else</c-> <c- p>{</c-></span><span class="line-no" data-line="65"></span><span class="line">        <c- n>mv</c-><c- p>[</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- p>(</c-><c- n>dstY</c-> <c- o>-</c-> <c- p>(</c-><c- n>srcY</c-> <c- o>&lt;&lt;</c-> <c- n>WARPEDMODEL_PREC_BITS</c-><c- p>))</c-> <c- o>>></c-> </span><span class="line-no" data-line="66"></span><span class="line">                  <c- p>(</c-><c- n>WARPEDMODEL_PREC_BITS</c-> <c- o>-</c-> <c- mi>3</c-><c- p>)</c-></span><span class="line-no" data-line="67"></span><span class="line">        <c- n>mv</c-><c- p>[</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- p>(</c-><c- n>dstX</c-> <c- o>-</c-> <c- p>(</c-><c- n>srcX</c-> <c- o>&lt;&lt;</c-> <c- n>WARPEDMODEL_PREC_BITS</c-><c- p>))</c-> <c- o>>></c-> </span><span class="line-no" data-line="68"></span><span class="line">                  <c- p>(</c-><c- n>WARPEDMODEL_PREC_BITS</c-> <c- o>-</c-> <c- mi>3</c-><c- p>)</c-></span><span class="line-no" data-line="69"></span><span class="line">    <c- p>}</c-></span><span class="line-no" data-line="70"></span><span class="line">    <c- n>mv</c-><c- p>[</c-> <c- mi>0</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-><c- n>MV_LOW</c-> <c- o>+</c-> <c- mi>1</c-><c- p>,</c-> <c- n>MV_UPP</c-> <c- o>-</c-> <c- mi>1</c-><c- p>,</c-> <c- n>mv</c-><c- p>[</c-> <c- mi>0</c-> <c- p>])</c-></span><span class="line-no" data-line="71"></span><span class="line">    <c- n>mv</c-><c- p>[</c-> <c- mi>1</c-> <c- p>]</c-> <c- o>=</c-> <c- n>Clip3</c-><c- p>(</c-><c- n>MV_LOW</c-> <c- o>+</c-> <c- mi>1</c-><c- p>,</c-> <c- n>MV_UPP</c-> <c- o>-</c-> <c- mi>1</c-><c- p>,</c-> <c- n>mv</c-><c- p>[</c-> <c- mi>1</c-> <c- p>])</c-></span><span class="line-no" data-line="72"></span><span class="line">    <c- k>return</c-> <c- n>mv</c-></span><span class="line-no" data-line="73"></span><span class="line"><c- p>}</c-></span></pre>
   <p>The function compression_mv (which compresses a motion vector component into fewer bits to reduce memory bandwidth) is specified as:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>compression_mv</c-><c- p>(</c-> <c- n>v</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- n>a</c-> <c- o>=</c-> <c- n>Abs</c-><c- p>(</c-> <c- n>v</c-> <c- p>)</c-></span><span class="line-no" data-line="3"></span><span class="line">    <c- n>stepLog2</c-> <c- o>=</c-> <c- n>Max</c-><c- p>(</c-> <c- mi>0</c-><c- p>,</c-> <c- n>FloorLog2</c-><c- p>(</c-> <c- n>a</c-> <c- p>)</c-> <c- o>-</c-> <c- mi>4</c-> <c- p>)</c-></span><span class="line-no" data-line="4"></span><span class="line">    <c- n>c</c-> <c- o>=</c-> <c- p>(</c-> <c- n>a</c-> <c- o>>></c-> <c- n>stepLog2</c-> <c- p>)</c-> <c- o>+</c-> <c- p>(</c-> <c- n>stepLog2</c-> <c- o>&lt;&lt;</c-> <c- mi>4</c-> <c- p>)</c-></span><span class="line-no" data-line="5"></span><span class="line">    <c- k>return</c-> <c- n>v</c-> <c- o>&lt;</c-> <c- mi>0</c-> <c- o>?</c-> <c- o>-</c-><c- n>c</c-> <c- o>:</c-> <c- n>c</c-></span><span class="line-no" data-line="6"></span><span class="line"><c- p>}</c-></span></pre>
   <p>The function uncompression_mv (which decompresses a motion vector component) is specified as:</p>
<pre class="language-c highlight line-numbered"><span class="line-no" data-line="1"></span><span class="line"><c- n>uncompression_mv</c-><c- p>(</c-> <c- n>v</c-> <c- p>)</c-> <c- p>{</c-></span><span class="line-no" data-line="2"></span><span class="line">    <c- n>c</c-> <c- o>=</c-> <c- n>Abs</c-><c- p>(</c-> <c- n>v</c-> <c- p>)</c-></span><span class="line-no" data-line="3"></span><span class="line">    <c- n>stepLog2</c-> <c- o>=</c-> <c- n>Max</c-><c- p>(</c-> <c- mi>0</c-><c- p>,</c-> <c- p>(</c-><c- n>c</c-> <c- o>>></c-> <c- mi>4</c-><c- p>)</c-> <c- o>-</c-> <c- mi>1</c-> <c- p>)</c-></span><span class="line-no" data-line="4"></span><span class="line">    <c- n>a</c-> <c- o>=</c-> <c- p>(</c-> <c- n>c</c-> <c- o>-</c-> <c- p>(</c-><c- n>stepLog2</c-> <c- o>&lt;&lt;</c-> <c- mi>4</c-><c- p>)</c-> <c- p>)</c-> <c- o>&lt;&lt;</c-> <c- n>stepLog2</c-></span><span class="line-no" data-line="5"></span><span class="line">    <c- k>return</c-> <c- n>v</c-> <c- o>&lt;</c-> <c- mi>0</c-> <c- o>?</c-> <c- o>-</c-><c- n>a</c-> <c- o>:</c-> <c- n>a</c-></span><span class="line-no" data-line="6"></span><span class="line"><c- p>}</c-></span></pre>
   <h3 class="heading settled" data-level="7.22" id="reference_frame_update_process"><span class="secno">7.22. </span><span class="content">Reference frame update process</span><a class="self-link" href="#reference_frame_update_process"></a></h3>
   <p>This process is invoked as the final step in decoding a frame.</p>
   <p>The inputs to this process are the decoded samples for the current frame
LrFrame[ plane ][ x ][ y ].</p>
   <p>The output from this process is an updated set of reference frames and
previous motion vectors.</p>
   <p>If this is the first time this process is invoked, the variable FrameCounter
(used to identify when a frame is stored in multiple reference frames)
is set equal to 0. Otherwise, the variable FrameCounter is incremented by 1.</p>
   <p>If frame_type is equal to KEY_FRAME and show_frame is equal to 1, the flush showable frames process specified in <a href="#flush_showable_frames_process">§ 7.20.5 Flush showable frames process</a> is invoked.</p>
   <p>For each value of i from 0 to NUM_REF_FRAMES - 1, the following applies if bit i of refresh_frame_flags is equal to 1 (i.e. if <code>(refresh_frame_flags >> i) &amp; 1</code> is equal to 1):</p>
   <ul>
    <li data-md>
     <p>If is_frame_eligible_for_output(i) is equal to 1, the output frame buffers process specified in <a href="#output_frame_buffers_process">§ 7.20.6 Output frame buffers process</a> is invoked with i as input.</p>
    <li data-md>
     <p>RefValid[ i ] is set equal to <code>(frame_type == KEY_FRAME &amp;&amp; show_frame) ? i == 0 : 1</code>.</p>
    <li data-md>
     <p>RefFrameWidth[ i ] is set equal to FrameWidth.</p>
    <li data-md>
     <p>RefFrameHeight[ i ] is set equal to FrameHeight.</p>
    <li data-md>
     <p>RefCropWidth[ i ] is set equal to CropWidth.</p>
    <li data-md>
     <p>RefCropHeight[ i ] is set equal to CropHeight.</p>
    <li data-md>
     <p>RefCropLeft[ i ] is set equal to CropLeft.</p>
    <li data-md>
     <p>RefCropTop[ i ] is set equal to CropTop.</p>
    <li data-md>
     <p>RefMiCols[ i ] is set equal to MiCols.</p>
    <li data-md>
     <p>RefMiRows[ i ] is set equal to MiRows.</p>
    <li data-md>
     <p>RefFrameType[ i ] is set equal to frame_type.</p>
    <li data-md>
     <p>RefSubsamplingX[ i ] is set equal to SubsamplingX.</p>
    <li data-md>
     <p>RefSubsamplingY[ i ] is set equal to SubsamplingY.</p>
    <li data-md>
     <p>RefMatrixCoefficients[ i ] is set equal to matrix_coefficients.</p>
    <li data-md>
     <p>RefLongTermId[ i ] is set equal to long_term_id.</p>
    <li data-md>
     <p>RefBitDepth[ i ] is set equal to BitDepth.</p>
    <li data-md>
     <p>RefNumPlanes[ i ] is set equal to NumPlanes.</p>
    <li data-md>
     <p>RefFilmGrainPresent[ i ] is set equal to film_grain_params_present.</p>
    <li data-md>
     <p>RefShowableFrame[ i ] is set equal to showable_frame.</p>
    <li data-md>
     <p>RefOrderHint[ i ] is set equal to OrderHint.</p>
    <li data-md>
     <p>RefOrderHintLsbs[ i ] is set equal to OrderHintLsbs.</p>
    <li data-md>
     <p>RefBaseQIdx[ i ] is set equal to base_q_idx.</p>
    <li data-md>
     <p>RefDeltaQUAc[ i ] is set equal to DeltaQUAc.</p>
    <li data-md>
     <p>RefDeltaQVAc[ i ] is set equal to DeltaQVAc.</p>
    <li data-md>
     <p>RefFrameFiltersOn[ i ] is set equal to a copy of frame_filters_on.</p>
    <li data-md>
     <p>RefFrameLrWienerNs[ i ] is set equal to a copy of FrameLrWienerNs.</p>
    <li data-md>
     <p>RefNumFilterClasses[ i ] is set equal to NumFilterClasses.</p>
    <li data-md>
     <p>RefCounter[ i ] is set equal to FrameCounter.</p>
    <li data-md>
     <p>RefNumTotalRefs[ i ] is set equal to NumTotalRefs.</p>
    <li data-md>
     <p>RefTLayerId[ i ] is set equal to obu_tlayer_id.</p>
    <li data-md>
     <p>RefMLayerId[ i ] is set equal to obu_mlayer_id.</p>
    <li data-md>
     <p>RefGmParams[ i ][ j ][ k ] is set equal to gm_params[ j ][ k ] for j = 0..REFS_PER_FRAME-1 and k = 0..5.</p>
    <li data-md>
     <p>SavedOrderHints[ i ][ j ] is set equal to OrderHints[ j ] for j = 0..REFS_PER_FRAME-1.</p>
    <li data-md>
     <p>FrameStore[ i ][ 0 ][ y ][ x ] is set equal to LrFrame[ 0 ][ y ][ x ] for x = 0..(MiCols * MI_SIZE-1), for y = 0..(MiRows * MI_SIZE-1).</p>
    <li data-md>
     <p>FrameStore[ i ][ plane ][ y ][ x ] is set equal to LrFrame[ plane ][ y ][ x ] for plane = 1..2, for x = 0..<code>(MiCols * MI_SIZE >> SubsamplingX) - 1</code>, for y = 0..<code>((MiRows * MI_SIZE >> SubsamplingY) - 1)</code>.</p>
    <li data-md>
     <p>SavedRefFrames[ i ][ y8 ][ x8 ][ list ] is set equal to MfRefFrames[ y8 ][ x8 ][ list ] for y8 = 0..<code>(MiRows>>1)-1</code>, for x8 = 0..<code>(MiCols>>1)-1</code>, for list = 0..1.</p>
    <li data-md>
     <p>SavedMvs[ i ][ y8 ][ x8 ][ list ][ comp ] is set equal to MfMvs[ y8 ][ x8 ][ list ][ comp ] for comp = 0..1, for <code>y8 = 0..(MiRows>>1)-1</code>, for <code>x8 = 0..(MiCols>>1)-1</code>, for list = 0..1.</p>
    <li data-md>
     <p>SavedGmParams[ i ][ ref ][ j ] is set equal to gm_params[ ref ][ j ] for ref = 0..REFS_PER_FRAME-1, for j = 0..5.</p>
    <li data-md>
     <p>SavedSegmentIds[ i ][ row ][ col ] is set equal to SegmentIds[ row ][ col ] for row = 0..MiRows-1, for col = 0..MiCols-1.</p>
    <li data-md>
     <p>The function save_cdfs( i ) is invoked (see below).</p>
    <li data-md>
     <p>If film_grain_params_present is equal to 1, the following ordered steps apply:</p>
     <ol>
      <li data-md>
       <p>The function load_grain_params is invoked with NUM_REF_FRAMES as input (see <a href="#film_grain_params_semantics">§ 6.13.22 Film grain params semantics</a>).</p>
      <li data-md>
       <p>The function save_grain_params( i ) is invoked (see below).</p>
     </ol>
    <li data-md>
     <p>The function save_segmentation_params( i ) is invoked (see below).</p>
    <li data-md>
     <p>The function save_ccso_params( i, plane ) is invoked (see below) for plane = 0..2.</p>
   </ul>
   <p>save_cdfs( ctx ) is a function call that indicates that all the CDF arrays are saved into <a data-link-type="dfn" href="#frame-context" id="ref-for-frame-context①">frame context</a> number ctx in the range 0 to (NUM_REF_FRAMES - 1).
When this function is invoked the following takes place:</p>
   <ul>
    <li data-md>
     <p>A copy of each CDF array mentioned in the semantics for init_coeff_cdfs and init_non_coeff_cdfs is saved in an area of memory indexed by ctx.</p>
   </ul>
   <p>save_grain_params( i ) is a function call that indicates that all the syntax elements that can be
read in film_grain_params should be saved into an area of memory indexed by i.</p>
   <p>save_segmentation_params( i ) is a function call that indicates that the values of
FeatureEnabled[ j ][ k ] and FeatureData[ j ][ k ] for j = 0 .. MAX_SEGMENTS-1, for k = 0 .. SEG_LVL_MAX-1 should be saved into an area of memory indexed by i.</p>
   <p>save_ccso_params( i, plane ) is a function call that indicates that certain variables and arrays are saved into an area of memory indexed by i and plane:</p>
   <ul>
    <li data-md>
     <p>CcsoLumaSizeLog2</p>
    <li data-md>
     <p>ccso_planes[plane]</p>
    <li data-md>
     <p>ccso_scale_idx[plane]</p>
    <li data-md>
     <p>ccso_bo_only[plane]</p>
    <li data-md>
     <p>ccso_quant_idx[plane]</p>
    <li data-md>
     <p>ccso_ext_filter[plane]</p>
    <li data-md>
     <p>ccso_max_band_log2[plane]</p>
    <li data-md>
     <p>ccso_edge_clf[plane]</p>
    <li data-md>
     <p>CcsoFilterOffset[plane]</p>
    <li data-md>
     <p>CcsoBlks[plane]</p>
   </ul>
   <p>is_frame_eligible_for_output is a function call that is specified in <a href="#output_showable_frame_process">§ 7.20.4 Output showable frame process</a>.</p>
   <h3 class="heading settled" data-level="7.23" id="reference_frame_loading_process"><span class="secno">7.23. </span><span class="content">Reference frame loading process</span><a class="self-link" href="#reference_frame_loading_process"></a></h3>
   <p>This process is the reverse of the reference frame update process specified in <a href="#reference_frame_update_process">§ 7.22 Reference frame update process</a>. It loads saved values for a previous reference
frame back into the current frame variables. The index of the saved reference frame to load is given by the syntax element frame_to_show_map_idx.</p>
   <ul>
    <li data-md>
     <p>FrameWidth is set equal to RefFrameWidth[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>FrameHeight is set equal to RefFrameHeight[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>CropWidth is set equal to RefCropWidth[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>CropHeight is set equal to RefCropHeight[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>CropLeft is set equal to RefCropLeft[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>CropTop is set equal to RefCropTop[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>MiCols is set equal to RefMiCols[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>MiRows is set equal to RefMiRows[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>SubsamplingX is set equal to RefSubsamplingX[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>SubsamplingY is set equal to RefSubsamplingY[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>matrix_coefficients is set equal to RefMatrixCoefficients[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>BitDepth is set equal to RefBitDepth[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>NumTotalRefs is set equal to RefNumTotalRefs[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>base_q_idx is set equal to RefBaseQIdx[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>obu_tlayer_id is set equal to RefTLayerId[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>obu_mlayer_id is set equal to RefMLayerId[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>DeltaQUAc is set equal to RefDeltaQUAc[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>DeltaQVAc is set equal to RefDeltaQVAc[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>frame_filters_on is set equal to a copy of RefFrameFiltersOn[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>NumFilterClasses is set equal to RefNumFilterClasses[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>FrameLrWienerNs is set equal to a copy of RefFrameLrWienerNs[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>OrderHint is set equal to RefOrderHint[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>OrderHintLsbs is set equal to RefOrderHintLsbs[ frame_to_show_map_idx ].</p>
    <li data-md>
     <p>OrderHints[ j ] is set equal to SavedOrderHints[ frame_to_show_map_idx ][ j ] for j = 0..REFS_PER_FRAME-1.</p>
    <li data-md>
     <p>LrFrame[ 0 ][ y ][ x ] is set equal to FrameStore[ frame_to_show_map_idx ][ 0 ][ y ][ x ] for x = 0..(MiCols * MI_SIZE-1), for y = 0..(MiRows * MI_SIZE-1).</p>
    <li data-md>
     <p>LrFrame[ plane ][ y ][ x ] is set equal to FrameStore[ frame_to_show_map_idx ][ plane ][ y ][ x ] for plane = 1..2, for x = 0..<code>(MiCols * MI_SIZE >> SubsamplingX) - 1</code>, for y = 0..<code>(MiRows * MI_SIZE >> SubsamplingY) - 1</code>.</p>
    <li data-md>
     <p>MfRefFrames[ y8 ][ x8 ][ list ] is set equal to SavedRefFrames[ frame_to_show_map_idx ][ y8 ][ x8 ][ list ] for y8 = 0..<code>(MiRows>>1)-1</code>, for <code>x8 = 0..(MiCols>>1)-1</code>, for list = 0..1.</p>
    <li data-md>
     <p>MfMvs[ y8 ][ x8 ][ list ][ comp ] is set equal to SavedMvs[ frame_to_show_map_idx ][ y8 ][ x8 ][ list ][ comp ] for comp = 0..1,for <code>y8 = 0..(MiRows>>1)-1</code>, for <code>x8 = 0..(MiCols>>1)-1</code>, for list = 0..1.</p>
    <li data-md>
     <p>gm_params[ ref ][ j ] is set equal to SavedGmParams[ frame_to_show_map_idx ][ ref ][ j ] for ref = 0..REFS_PER_FRAME-1, for j = 0..5.</p>
    <li data-md>
     <p>SegmentIds[ row ][ col ] is set equal to SavedSegmentIds[ frame_to_show_map_idx ][ row ][ col ] for row = 0..MiRows-1, for col = 0..MiCols-1.</p>
